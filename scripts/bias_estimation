#!/usr/bin/env python

from __future__ import absolute_import, division, print_function
import matplotlib.pyplot as plt
from ros_numpy import msgify, numpify
from rosbag import Bag, ROSBagException, Compression
import rospy
from sensor_msgs.msg import PointCloud2
from geometry_msgs.msg import PointStamped
from tf2_ros import BufferCore, TransformException
from tqdm import tqdm
import numpy as np
from numpy.lib.recfunctions import unstructured_to_structured, structured_to_unstructured
from scipy.spatial.transform import Rotation
from depth_correction.filters import filter_box, filter_depth, filter_grid
import open3d as o3d


VIS = 1

def str2bool(v):
    return v.lower() in ('1', 'yes', 'true', 't', 'y')

def get_topic_types(bag):
    return {k: v.msg_type for k, v in bag.get_type_and_topic_info().topics.items()}

def slots(msg):
    """Return message attributes (slots) as list."""
    return [getattr(msg, var) for var in msg.__slots__]

def normalize(v):
    norm = np.linalg.norm(v)
    if norm == 0:
        return v
    return v / norm

def load_buffer(bag_paths):
    tf_topics = ['/tf', '/tf_static']

    # tf_buffer = BufferCore(cache_time=rospy.Duration(2**31 - 1))
    # tf_buffer = BufferCore(cache_time=rospy.Duration(24 * 60 * 60))
    tf_buffer = BufferCore(rospy.Duration(24 * 60 * 60))
    
    for path in bag_paths:
        try:
            with Bag(path, 'r') as bag:
                for topic, msg, stamp in tqdm(bag.read_messages(topics=tf_topics),
                                              desc='%s: reading transforms' % path.split('/')[-1],
                                              total=bag.get_message_count(topic_filters=tf_topics)):
                    if topic == '/tf':
                        for tf in msg.transforms:
                            tf_buffer.set_transform(tf, 'bag')
                    elif topic == '/tf_static':
                        for tf in msg.transforms:
                            tf_buffer.set_transform_static(tf, 'bag')
                        
        except ROSBagException as ex:
            print('Could not read %s: %s' % (path, ex))

    return tf_buffer


def transform_cloud(cloud, Tr):
    assert isinstance(cloud, np.ndarray)
    if cloud.dtype.names:
        pts = structured_to_unstructured(cloud[['x', 'y', 'z']])
    else:
        pts = cloud
    R, t = Tr[:-1, :-1], Tr[:-1, -1:]
    pts_tr = pts @ R.T + t.T
    if cloud.dtype.names:
        cloud_tr = cloud.copy()
        cloud_tr[['x', 'y', 'z']] = unstructured_to_structured(pts_tr, names=['x', 'y', 'z'])
    else:
        cloud_tr = pts_tr
    return cloud_tr

def visualize_cloud_3d(ax, cloud, **kwargs):
    ax.plot(cloud['x'], cloud['y'], cloud['z'], '.', **kwargs)

# https://stackoverflow.com/questions/13685386/matplotlib-equal-unit-length-with-equal-aspect-ratio-z-axis-is-not-equal-to
def set_axes_equal(ax):
    '''Make axes of 3D plot have equal scale so that spheres appear as spheres,
    cubes as cubes, etc..  This is one possible solution to Matplotlib's
    ax.set_aspect('equal') and ax.axis('equal') not working for 3D.

    Input
      ax: a matplotlib axis, e.g., as output from plt.gca().
    '''

    x_limits = ax.get_xlim3d()
    y_limits = ax.get_ylim3d()
    z_limits = ax.get_zlim3d()

    x_range = abs(x_limits[1] - x_limits[0])
    x_middle = np.mean(x_limits)
    y_range = abs(y_limits[1] - y_limits[0])
    y_middle = np.mean(y_limits)
    z_range = abs(z_limits[1] - z_limits[0])
    z_middle = np.mean(z_limits)

    # The plot bounding box is a sphere in the sense of the infinity
    # norm, hence I call half the max range the plot radius.
    plot_radius = 0.5*max([x_range, y_range, z_range])

    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])
    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])
    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])


def bias_estimation(bag_path=None, cloud_topic=None, leica_topic=None):

    # tf_buffer = load_buffer(bag_paths)

    measurements = {'world_corner': np.asarray([5.2622, -0.5873, 0.1312]),
                    'world_base': np.asarray([5.2620, -0.0084, -0.3582]),
                    'world_crystal': np.asarray([5.2567, 0.5753, 0.1589])}
    # for white side of the calibration board
    # measurements = {'world_corner': np.asarray([5.2576, 0.5684, 0.1379]),
    #                 'world_base': np.asarray([5.2603, -0.0051, -0.3578]),
    #                 'world_crystal': np.asarray([5.2441, -0.5964, 0.1509])}
    board_height = np.abs(measurements['world_corner'][2] - measurements['world_base'][2]) - 0.01  # Z
    board_length = np.abs(measurements['world_crystal'][1] - measurements['world_corner'][1])  # Y
    board_width = 0.015  # X
    
    def generate_board_cloud(n_pts=100):
        np.random.seed(135)
        length = board_length
        height = board_height
        width = board_width
        x0, y0, z0 = measurements['world_corner'] - measurements['world_base']
        z0 -= height
        origin = np.asarray([x0, y0, z0])  # in base frame
        points = (width, length, height) * np.random.uniform(0, 1, (n_pts, 3)) + origin
        cloud = unstructured_to_structured(np.asarray(points, dtype=np.float32), names=['x', 'y', 'z'])
        return cloud

    def visualize(axes_2d, ouster_cloud, board_cloud, board_pose, board_length, pt2pl_errs, angles):
        ax = axes_2d[0, 0]
        ax.cla()
        ax.plot(board_cloud['x'], board_cloud['y'], 'o', color='b', markersize=4)

        ax.set_xlim([-2, 8])
        ax.set_ylim([-5, 5])
        # coordinate system vis
        ax.spines['top'].set_color('none')
        ax.spines['bottom'].set_position('zero')
        ax.spines['left'].set_position('zero')
        ax.spines['right'].set_color('none')

        # circumference
        circle = plt.Circle(board_pose[:2], board_length / 2, color='b', fill=False)
        ax.add_patch(circle)

        # ouster points
        # ax.plot(ouster_cloud['x'], ouster_cloud['y'], '.', markersize=0.4, color='g')
        half_height = np.percentile(ouster_cloud['z'], 50)
        cloud_vis = ouster_cloud[ouster_cloud['z'] <= half_height]
        ax.plot(cloud_vis['x'], cloud_vis['y'], '.', markersize=2, color='g')

        ax = axes_2d[0, 1]
        ax.cla()
        ax.plot(board_cloud['y'], board_cloud['z'], 'o', color='b', markersize=4)

        ax.set_xlim([-3, 3])
        ax.set_ylim([-3, 3])
        # coordinate system vis
        ax.spines['top'].set_color('none')
        ax.spines['bottom'].set_position('zero')
        ax.spines['left'].set_position('zero')
        ax.spines['right'].set_color('none')

        # ouster points
        # ax.plot(ouster_cloud['y'], ouster_cloud['z'], '.', markersize=0.4, color='g')
        cloud_vis = ouster_cloud[ouster_cloud['x'] >= 0.0]
        ax.plot(cloud_vis['y'], cloud_vis['z'], '.', markersize=2, color='g')

        ax = axes_2d[0, 2]
        ax.cla()
        ax.set_ylim([0, 0.2])
        ax.set_xlim([-180, 180])
        ax.plot(angles, pt2pl_errs, color='k')

    board_cloud0 = generate_board_cloud()
    board_normal = np.asarray([1., 0., 0.])
    board_cloud = None
    ouster_cloud = None
    board_pose = measurements['world_base']

    Tr_world_ouster = np.array([[0.99832296, -0.05795125, -0.0035224, 0.],
                                [0.05796774, 0.99802342, 0.02213984, 0.],
                                [0.0023, -0.0223, 0.9997, -0.1],
                                [0., 0., 0., 1.]])
    # print(np.rad2deg(Rotation.from_matrix(Tr_world_ouster[:3, :3]).as_euler('xyz')))
    # [-1.27808371 -0.12987161  3.32463666]

    # Tr_world_ouster = np.eye(4)
    # Tr_world_ouster[:3, 3] = [0, 0, -0.1]
    # Rx = np.asarray(Rotation.from_euler('x', -2, degrees=True).as_matrix())
    # Ry = np.asarray(Rotation.from_euler('y', 0., degrees=True).as_matrix())
    # Rz = np.asarray(Rotation.from_euler('z', 3.4, degrees=True).as_matrix())
    # Tr_world_ouster[:3, :3] = Rz
    # Tr_world_ouster[:3, :3] = Rx @ Ry @ Rz

    _, axes_2d = plt.subplots(1, 3, figsize=(18., 6.), constrained_layout=True, squeeze=False)
    pt2pl_errs = []
    angles = []
    with Bag(bag_path, 'r') as bag:
        for topic, msg, stamp in tqdm(bag.read_messages(topics=[cloud_topic, leica_topic])):
            if topic == cloud_topic:
                msg = PointCloud2(*slots(msg))

                ouster_cloud = numpify(msg)
                ouster_cloud = ouster_cloud.reshape((-1,))
                ouster_cloud = ouster_cloud[::5]
                ouster_cloud = filter_depth(ouster_cloud, min=0., max=8.)
                ouster_cloud = transform_cloud(ouster_cloud, Tr_world_ouster)
                ouster_cloud_box = filter_box(ouster_cloud,
                                              pose=board_pose + np.asarray([0, 0, board_height / 2]),
                                              size=0.8 * np.asarray([board_length, board_length, board_height]))

            elif topic == leica_topic:
                # get board orientation in world frame
                msg = PointStamped(*slots(msg))
                crystal_pose = np.asarray([msg.point.x, msg.point.y, msg.point.z])
                v1 = crystal_pose - board_pose
                v1 = normalize(v1)
                angle_z = np.arctan2(v1[1], v1[0]) - np.pi / 2

                # generate board cloud in world frame
                R = np.asarray(Rotation.from_euler('z', angle_z, degrees=False).as_matrix())
                Tr_world_board = np.eye(4)
                Tr_world_board[:3, :3] = R
                Tr_world_board[:3, 3] = board_pose
                board_cloud = transform_cloud(board_cloud0, Tr_world_board)
                board_normal = np.cross(v1, [0, 0, 1])

            if ouster_cloud is None or board_cloud is None:
                continue

            points = structured_to_unstructured(ouster_cloud_box[['x', 'y', 'z']])
            if len(points) > 0:
                pt2pl = np.abs(board_normal[None] @ (points - board_pose).T).mean()
                pt2pl_errs.append(pt2pl)
                angles.append(np.rad2deg(angle_z))
                print('For board angle %.1f [deg], point-to-plane distance: %.3f [m]' %
                      (np.rad2deg(angle_z), pt2pl))
            else:
                print('No ouster points in the box')

            # visualization
            if VIS:

                # ax = plt.axes(projection='3d')
                # visualize_cloud_3d(ax, ouster_cloud, color='g')
                # visualize_cloud_3d(ax, board_cloud, color='b')
                # set_axes_equal(ax)
                # plt.show()
                #
                # pcd = o3d.geometry.PointCloud()
                # pcd.points = o3d.utility.Vector3dVector(structured_to_unstructured(board_cloud[['x', 'y', 'z']]))
                # pcd.normals = o3d.utility.Vector3dVector(np.repeat(board_normal[None], len(board_cloud), axis=0))
                # o3d.visualization.draw_geometries([pcd], point_show_normal=True)

                # visualize(axes_2d, ouster_cloud, board_cloud, board_pose, board_length, pt2pl_errs)
                visualize(axes_2d, ouster_cloud_box, board_cloud, board_pose, board_length, pt2pl_errs, angles)
                plt.pause(0.01)


def main():
    bag_path = '/home/ruslan/data/datasets/fee_corridor/bags/leica_ouster/small_board/depth_correction_black_board_ouster_leica_2023-02-02-14-50-38.bag'
    # bag_path = '/home/ruslan/data/datasets/fee_corridor/bags/leica_ouster/small_board/depth_correction_white_board_ouster_leica_2023-02-02-13-44-08.bag'

    cloud_topic = '/ouster/points'
    leica_topic = '/total_station_driver/ts_points'
    bias_estimation(bag_path, cloud_topic, leica_topic)


if __name__ == '__main__':
    main()
