#!/usr/bin/env python

from __future__ import absolute_import, division, print_function
import matplotlib.pyplot as plt
from ros_numpy import msgify, numpify
from rosbag import Bag
from sensor_msgs.msg import PointCloud2
from geometry_msgs.msg import PointStamped
from tqdm import tqdm
import numpy as np
from numpy.lib.recfunctions import unstructured_to_structured, structured_to_unstructured
from scipy.spatial.transform import Rotation
from depth_correction.filters import filter_box, filter_depth, filter_grid
import open3d as o3d
from time import time
import torch
from depth_correction.model import load_model
from depth_correction.config import Config, Model
from depth_correction.preproc import local_feature_cloud
from depth_correction.depth_cloud import DepthCloud

VIS = 1
CORRECTION = 0
TIME_TOL = 0.05

cfg = Config()
# cfg.model_class = Model.ScaledPolynomial
# cfg.model_kwargs = {'w': [-0.0011], 'exponent': [4]}
cfg.model_class = Model.Polynomial
cfg.model_kwargs = {'w': [-0.02], 'exponent': [4]}
cfg.eigenvalue_ratio_bounds = []


def str2bool(v):
    return v.lower() in ('1', 'yes', 'true', 't', 'y')

def get_topic_types(bag):
    return {k: v.msg_type for k, v in bag.get_type_and_topic_info().topics.items()}

def slots(msg):
    """Return message attributes (slots) as list."""
    return [getattr(msg, var) for var in msg.__slots__]

def normalize(v):
    norm = np.linalg.norm(v)
    if norm == 0:
        return v
    return v / norm

def correction(cloud, model, cfg, inc_angles=None):
    with torch.no_grad():
        # Assume that depth and grid filters are run earlier.
        if inc_angles is None:
            cloud = local_feature_cloud(cloud, cfg)
        else:
            cloud = DepthCloud.from_structured_array(cloud)
            cloud.inc_angles = torch.from_numpy(inc_angles)

        cloud = model(cloud)
        cloud.update_points()
        print('Estimated mean inc angle: %f [deg]' % np.rad2deg(cloud.inc_angles.cpu().numpy().mean()))
        # cloud.visualize(colors=cloud.inc_angles, window_name='Normals')
    output_cloud = cloud.to_structured_array()
    return output_cloud

def transform_cloud(cloud, Tr):
    assert isinstance(cloud, np.ndarray)
    if cloud.dtype.names:
        pts = structured_to_unstructured(cloud[['x', 'y', 'z']])
    else:
        pts = cloud
    R, t = Tr[:-1, :-1], Tr[:-1, -1:]
    pts_tr = pts @ R.T + t.T
    if cloud.dtype.names:
        cloud_tr = cloud.copy()
        cloud_tr[['x', 'y', 'z']] = unstructured_to_structured(pts_tr, names=['x', 'y', 'z'])
    else:
        cloud_tr = pts_tr
    return cloud_tr

def visualize_cloud_3d(ax, cloud, **kwargs):
    ax.plot(cloud['x'], cloud['y'], cloud['z'], '.', **kwargs)

# https://stackoverflow.com/questions/13685386/matplotlib-equal-unit-length-with-equal-aspect-ratio-z-axis-is-not-equal-to
def set_axes_equal(ax):
    '''Make axes of 3D plot have equal scale so that spheres appear as spheres,
    cubes as cubes, etc..  This is one possible solution to Matplotlib's
    ax.set_aspect('equal') and ax.axis('equal') not working for 3D.

    Input
      ax: a matplotlib axis, e.g., as output from plt.gca().
    '''

    x_limits = ax.get_xlim3d()
    y_limits = ax.get_ylim3d()
    z_limits = ax.get_zlim3d()

    x_range = abs(x_limits[1] - x_limits[0])
    x_middle = np.mean(x_limits)
    y_range = abs(y_limits[1] - y_limits[0])
    y_middle = np.mean(y_limits)
    z_range = abs(z_limits[1] - z_limits[0])
    z_middle = np.mean(z_limits)

    # The plot bounding box is a sphere in the sense of the infinity
    # norm, hence I call half the max range the plot radius.
    plot_radius = 0.5*max([x_range, y_range, z_range])

    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])
    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])
    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])


def bias_estimation(bag_path=None, cloud_topic=None, leica_topic=None):
    def generate_board_cloud(n_pts=500):
        np.random.seed(135)
        length = board_length
        height = board_height
        width = board_width
        x0, y0, z0 = measurements['world_corner'] - measurements['world_base']
        z0 -= height
        origin = np.asarray([x0, y0, z0])  # in base frame
        points = (width, length, height) * np.random.uniform(0, 1, (n_pts, 3)) + origin
        cloud = unstructured_to_structured(np.asarray(points, dtype=np.float32), names=['x', 'y', 'z'])
        return cloud

    def visualize(axes_2d, ouster_cloud, board_cloud, board_pose, board_length, board_normal, pt2pl_errs, angles):
        ax = axes_2d[0, 0]
        ax.cla()
        ax.plot(board_cloud['x'], board_cloud['y'], 'o', color='b')

        # ax.set_xlim([-2, 8])
        # ax.set_ylim([-5, 5])
        # coordinate system vis
        ax.spines['top'].set_color('none')
        ax.spines['bottom'].set_position('zero')
        ax.spines['left'].set_position('zero')
        ax.spines['right'].set_color('none')

        # circumference
        circle = plt.Circle(board_pose[:2], board_length / 2, color='b', fill=False)
        ax.add_patch(circle)

        # ouster points
        half_height = np.percentile(ouster_cloud['z'], 50)
        cloud_vis = ouster_cloud[ouster_cloud['z'] <= half_height]
        ax.plot(cloud_vis['x'], cloud_vis['y'], 'o', color='g')
        ax.quiver(cloud_vis['x'], cloud_vis['y'], board_normal[0], board_normal[1])

        ax = axes_2d[0, 1]
        ax.cla()
        ax.plot(board_cloud['y'], board_cloud['z'], 'o', color='b')

        # rectangle = plt.Rectangle(crystal_pose[1:3], -board_length, -board_height, edgecolor='b', facecolor='none')
        # ax.add_patch(rectangle)

        # ax.set_xlim([-3, 3])
        # ax.set_ylim([-3, 3])
        # coordinate system vis
        ax.spines['top'].set_color('none')
        ax.spines['bottom'].set_position('zero')
        ax.spines['left'].set_position('zero')
        ax.spines['right'].set_color('none')

        # ouster points
        cloud_vis = ouster_cloud[ouster_cloud['x'] >= 0.0]
        ax.plot(cloud_vis['y'], cloud_vis['z'], 'o', color='g')

        ax = axes_2d[0, 2]
        ax.cla()
        # ax.set_ylim([0, 0.25])
        # ax.set_xlim([-10, 100])
        ax.plot(angles, pt2pl_errs, '--', color='k')

    # tf_buffer = load_buffer(bag_paths)

    measurements = {'world_corner': np.asarray([5.2622, -0.5873, 0.1312]),
                    'world_base': np.asarray([5.2620, -0.0084, -0.3582]),
                    'world_crystal': np.asarray([5.2567, 0.5753, 0.1589])}
    # for white side of the calibration board
    # measurements = {'world_corner': np.asarray([5.2576, 0.5684, 0.1379]),
    #                 'world_base': np.asarray([5.2603, -0.0051, -0.3578]),
    #                 'world_crystal': np.asarray([5.2441, -0.5964, 0.1509])}
    board_height = np.abs(measurements['world_corner'][2] - measurements['world_base'][2]) - 0.01  # Z
    board_length = np.abs(measurements['world_crystal'][1] - measurements['world_corner'][1])  # Y
    board_width = 0.015  # X

    model = load_model(cfg=cfg)

    board_cloud0 = generate_board_cloud()
    board_normal = np.asarray([1., 0., 0.])
    board_cloud = None
    ouster_cloud = None
    board_pose = measurements['world_base']

    Tr_world_ouster = np.array([[0.99832296, -0.05795125, -0.0035224, 0.],
                                [0.05796774, 0.99802342, 0.02213984, 0.],
                                [0.0023, -0.0223, 0.9997, -0.1],
                                [0., 0., 0., 1.]])
    # print(np.rad2deg(Rotation.from_matrix(Tr_world_ouster[:3, :3]).as_euler('xyz')))
    # [-1.27808371 -0.12987161  3.32463666]

    # Tr_world_ouster = np.eye(4)
    # Tr_world_ouster[:3, 3] = [0, 0, -0.1]
    # Rx = np.asarray(Rotation.from_euler('x', -2, degrees=True).as_matrix())
    # Ry = np.asarray(Rotation.from_euler('y', 0., degrees=True).as_matrix())
    # Rz = np.asarray(Rotation.from_euler('z', 3.4, degrees=True).as_matrix())
    # Tr_world_ouster[:3, :3] = Rz
    # Tr_world_ouster[:3, :3] = Rx @ Ry @ Rz

    if VIS: _, axes_2d = plt.subplots(1, 3, figsize=(18., 6.), squeeze=False)
    pt2pl_errs = []
    angles = []
    R = None
    with Bag(bag_path, 'r') as bag:
        for topic, msg, stamp in tqdm(bag.read_messages(topics=[cloud_topic, leica_topic])):

            if topic == cloud_topic:
                t0 = time()

                msg = PointCloud2(*slots(msg))
                cloud_time = stamp.to_sec()

                ouster_cloud = numpify(msg)
                ouster_cloud = ouster_cloud.reshape((-1,))
                # ouster_cloud = ouster_cloud[::5]
                # ouster_cloud = filter_grid(ouster_cloud, 0.05)
                ouster_cloud = filter_depth(ouster_cloud, min=0., max=8.)
                ouster_cloud = transform_cloud(ouster_cloud, Tr_world_ouster)
                ouster_cloud_box = filter_box(ouster_cloud,
                                              box_center=board_pose + np.asarray([-0.1, 0, board_height / 2]),
                                              box_size=np.asarray([0.3, 0.8*board_length, board_height]),
                                              box_orient=R)
                # print('Cloud processing took: %.3f [sec]' % (time() - t0))

            if topic == leica_topic:
                t0 = time()
                # get board orientation in world frame
                msg = PointStamped(*slots(msg))
                leica_time = stamp.to_sec()

                crystal_pose = np.asarray([msg.point.x, msg.point.y, msg.point.z])
                v1 = crystal_pose - board_pose
                v1 = normalize(v1)
                angle_z = np.arctan2(v1[1], v1[0]) - np.pi / 2

                # generate board cloud in world frame
                R = np.asarray(Rotation.from_euler('z', angle_z, degrees=False).as_matrix())
                Tr_world_board = np.eye(4)
                Tr_world_board[:3, :3] = R
                Tr_world_board[:3, 3] = board_pose
                board_cloud = transform_cloud(board_cloud0, Tr_world_board)
                board_normal = np.cross([0, 0, 1], v1)
                # orient normal towards lidar location
                board_normal *= -np.sign(board_pose @ board_normal)

                # print('Board localization took: %.3f [sec]' % (time() - t0))

            if ouster_cloud is None or board_cloud is None:
                continue

            # if np.rad2deg(angle_z) < 60:
            #     continue

            if np.abs(cloud_time - leica_time) > TIME_TOL:
                print('Cloud and leica msgs time difference is large: %.3f > %.3f [sec]' %
                      (np.abs(cloud_time - leica_time), TIME_TOL))
                continue

            if len(ouster_cloud_box) > 0:
                if CORRECTION:
                    ouster_cloud_box = correction(cloud=ouster_cloud_box, model=model, cfg=cfg,
                                                  inc_angles=np.repeat([angle_z], len(ouster_cloud_box))[None].T)
                points = structured_to_unstructured(ouster_cloud_box[['x', 'y', 'z']])

                dists = board_normal @ (points - board_pose).T
                # inl_mask = dists >= -0.05  # filter out hand points
                # dists = dists[inl_mask]
                # ouster_cloud_box = ouster_cloud_box[inl_mask]

                pt2pl = np.abs(dists).mean()
                pt2pl_errs.append(pt2pl)
                angles.append(np.rad2deg(angle_z))
                print('For board angle %.1f [deg], point-to-plane distance: %.3f [m]' %
                      (np.rad2deg(angle_z), pt2pl))
            else:
                print('No ouster points in the box for box angle: %.1f [deg]' % angle_z)
                continue

            # visualization
            if VIS:

                # ax = plt.axes(projection='3d')
                # visualize_cloud_3d(ax, ouster_cloud, color='g')
                # visualize_cloud_3d(ax, board_cloud, color='b')
                # set_axes_equal(ax)
                # plt.show()

                # pcd = o3d.geometry.PointCloud()
                # pcd.points = o3d.utility.Vector3dVector(structured_to_unstructured(board_cloud[['x', 'y', 'z']]))
                # pcd.normals = o3d.utility.Vector3dVector(np.repeat(board_normal[None], len(board_cloud), axis=0))
                # o3d.visualization.draw_geometries([pcd], point_show_normal=True)

                # visualize(axes_2d, ouster_cloud, board_cloud, board_pose, board_length, pt2pl_errs)
                visualize(axes_2d, ouster_cloud_box,
                          board_cloud, board_pose, board_length, board_normal,
                          pt2pl_errs, angles)
                plt.pause(0.01)

    if len(pt2pl_errs) > 0:
        angles = np.asarray(angles)
        pt2pl_errs = np.asarray(pt2pl_errs)
        print('point-to-plane distance: %.3f (mean, [m]),  %.3f (max, [m])' %
              (np.mean(pt2pl_errs).item(), np.max(pt2pl_errs).item()))
        print('point-to-plane distance for angles > 60 [deg]: %.3f (mean, [m]),  %.3f (max, [m])' %
              (np.mean(pt2pl_errs[angles > 60.]).item(), np.max(pt2pl_errs[angles > 60.]).item()))

        plt.figure()
        plt.title('point-to-plane distance: %.3f (mean, [m]),  %.3f (max, [m])' %
                  (np.mean(pt2pl_errs).item(), np.max(pt2pl_errs).item()))
        plt.plot(angles, pt2pl_errs, color='k')
        plt.savefig('/home/ruslan/Desktop/bias_estimation_depth_correction_%s_model_%s_%s.png' %
                    (CORRECTION, cfg.model_class, cfg.model_kwargs))
        plt.show()


def main():
    bag_path = '/home/ruslan/data/datasets/fee_corridor/bags/leica_ouster/small_board/depth_correction_black_board_ouster_leica_2023-02-02-14-50-38.bag'
    # bag_path = '/home/ruslan/data/datasets/fee_corridor/bags/leica_ouster/small_board/depth_correction_white_board_ouster_leica_2023-02-02-13-44-08.bag'

    cloud_topic = '/ouster/points'
    leica_topic = '/total_station_driver/ts_points'
    bias_estimation(bag_path, cloud_topic, leica_topic)


if __name__ == '__main__':
    main()
