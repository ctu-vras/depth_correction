#!/usr/bin/env python

from __future__ import absolute_import, division, print_function
from argparse import ArgumentParser
import numpy as np
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured
import os
from rosbag import Bag
from ros_numpy import numpify
from tqdm import tqdm
from sensor_msgs.msg import PointCloud2
from geometry_msgs.msg import PointStamped
import matplotlib.pyplot as plt
import open3d as o3d
from scipy.spatial.transform import Rotation
from depth_correction.filters import filter_box
from depth_correction.loss import point_to_point_dist
import torch
from depth_correction.preproc import local_feature_cloud
from depth_correction.config import Config, Model
from depth_correction.model import load_model
from depth_correction.utils import absolute_orientation
from scipy.spatial import cKDTree


measurements = {'subt_corner': np.asarray([5.2622, -0.5873, 0.1312]),
                'subt_base': np.asarray([5.2620, -0.0084, -0.3582]),
                'subt_crystal': np.asarray([5.2567, 0.5753, 0.1589])}
board_height = measurements['subt_corner'][2] - measurements['subt_base'][2] - 0.01  # Z
board_length = measurements['subt_crystal'][1] - measurements['subt_corner'][1]  # Y
board_width = 0.015  # X

def get_arg_parser():
    parser = ArgumentParser(description='Compute localization accuracy from SLAM and data set data.')
    # parser.add_argument('bag_paths', nargs='+', default=None, help='Input bag files.')
    return parser


def slots(msg):
    return [getattr(msg, var) for var in msg.__slots__]


def get_crystal_poses(bag_path, leica_topic='/total_station_driver/ts_points'):
    poses = []
    stamps = []
    with Bag(bag_path, 'r') as bag:
        for topic, msg, stamp in bag.read_messages(topics=[leica_topic]):
            msg = PointStamped(*slots(msg))
            pose = np.array([msg.point.x, msg.point.y, msg.point.z])
            poses.append(pose)
            stamps.append(stamp)
    return poses, stamps


def get_static_crystal_poses(poses, stamps, pose_th=0.001, static_window_size=10):
    i = 0
    static_poses = []
    static_stamps = []
    while True:
        window_size = 0
        for p in poses[i:]:
            if np.linalg.norm(poses[i] - p) > pose_th:
                break
            window_size += 1
        # print('Pose %i / %i is static for %i iters' % (i, len(poses), window_size))

        i += window_size
        if i >= len(poses):
            break

        if window_size > static_window_size:
            static_poses.append(poses[i])
            static_stamps.append(stamps[i])

    return static_poses, static_stamps


def get_static_clouds(bag_path, static_stamps, time_th=0.1, ouster_topic='/ouster/points'):
    static_clouds = []

    i = 0
    with Bag(bag_path, 'r') as bag:
        for topic, msg, stamp in tqdm(bag.read_messages(topics=[ouster_topic])):

            if i >= len(static_stamps):
                break

            if 0 < (stamp.to_sec() - static_stamps[i].to_sec()) < time_th:
                i += 1

                msg = PointCloud2(*slots(msg))
                cloud = numpify(msg)
                if cloud.ndim == 2:
                    cloud = cloud.reshape((-1,))
                static_clouds.append(cloud)

    return static_clouds


def visualize_clouds(clouds):
    pcds = []
    np.random.seed(135)
    for cloud in clouds:
        pcd = o3d.geometry.PointCloud()
        if cloud.dtype.names:
            points = structured_to_unstructured(cloud[['x', 'y', 'z']])
        else:
            points = cloud
        if points.ndim == 3:
            points = points.reshape((-1, 3))
        pcd.points = o3d.utility.Vector3dVector(points)
        pcd.colors = o3d.utility.Vector3dVector(np.random.uniform(0, 1, 3) + np.zeros_like(points))
        pcds.append(pcd)
    o3d.visualization.draw_geometries(pcds)


def generate_board_cloud(n_pts=1000):
    np.random.seed(135)
    x0, y0, z0 = measurements['subt_corner'] - measurements['subt_base']
    z0 -= board_height
    x0 -= board_width / 2.
    origin = np.asarray([x0, y0, z0])  # in base frame
    points = (board_width, board_length, board_height) * np.random.uniform(0, 1, (n_pts, 3)) + origin
    cloud = unstructured_to_structured(np.asarray(points, dtype=np.float32), names=['x', 'y', 'z'])
    return cloud


def transform_cloud(cloud, Tr):
    assert isinstance(cloud, np.ndarray)
    if cloud.dtype.names:
        pts = structured_to_unstructured(cloud[['x', 'y', 'z']])
    else:
        pts = cloud
    R, t = Tr[:-1, :-1], Tr[:-1, -1:]
    pts_tr = pts @ R.T + t.T
    if cloud.dtype.names:
        cloud_tr = cloud.copy()
        cloud_tr[['x', 'y', 'z']] = unstructured_to_structured(pts_tr, names=['x', 'y', 'z'])
    else:
        cloud_tr = pts_tr
    return cloud_tr


def normalize(v):
    norm = np.linalg.norm(v)
    if norm == 0:
        return v
    return v / norm

def correction(cloud, model, cfg):
    with torch.no_grad():
        # Assume that depth and grid filters are run earlier.
        cloud = local_feature_cloud(cloud, cfg)

        cloud = model(cloud)
        cloud.update_points()
    output_cloud = cloud.to_structured_array()
    return output_cloud

def angle_from_leica(pose):
    v1 = pose - measurements['subt_base']
    v1 = normalize(v1)
    angle_z = np.arctan2(v1[1], v1[0]) - np.pi / 2
    normal = normalize(np.cross(np.array([0, 0, 1]), v1))
    return angle_z, normal

def icp_alignment(x, y, Tr_init=np.eye(4), inl_ratio=1.0, n_iters=100):
    y_index = cKDTree(y)
    Tr_res = Tr_init

    d0, _ = y_index.query(x)
    for _ in tqdm(range(n_iters)):
        d, idx = y_index.query(x)
        dist_th = np.percentile(d, 100 * inl_ratio)
        inl_mask = d <= dist_th
        x_inl = x[inl_mask]
        y_inl = y[idx[inl_mask]]
        Tr = absolute_orientation(x_inl.T, y_inl.T)
        x = transform_cloud(x, Tr)

        Tr_res = Tr_res @ Tr

    print('Alignment error: %.3f / %.3f' % (d.mean(), d0.mean()))
    # visualize_clouds([x, y])
    return Tr_res

def eval(cloud, board_cloud, board_normal):
    ouster_points = structured_to_unstructured(cloud[['x', 'y', 'z']])
    board_points = structured_to_unstructured(board_cloud[['x', 'y', 'z']])

    # point to PLANE
    v_diff = ouster_points - np.array([0, 0, 0])
    point_to_plane = (v_diff @ board_normal[None].T).mean()

    # point to POINT distance
    point_to_point = point_to_point_dist([board_points, ouster_points],
                                         icp_inlier_ratio=0.9, differentiable=False)
    return point_to_point, point_to_plane

def bias_estimation():
    data_path = '/home/ruslan/data/bags/depth_correction/leica_ouster/small_board/'
    bag_path = os.path.join(data_path, 'depth_correction_black_board_ouster_leica_2023-02-02-14-50-38.bag')

    cfg = Config()
    cfg.model_class = Model.ScaledPolynomial
    cfg.model_kwargs = {'w': [-0.0011], 'exponent': [4]}
    cfg.eigenvalue_ratio_bounds = []
    cfg.log_filters = True
    model = load_model(cfg=cfg)

    # get all crystal poses
    crystal_poses, stamps = get_crystal_poses(bag_path)
    print('Found %i poses' % len(crystal_poses))

    # get static poses
    static_crystal_poses, static_stamps = get_static_crystal_poses(crystal_poses, stamps)
    print('Found %i static poses' % len(static_crystal_poses))
    # plt.figure()
    # plt.plot([s.to_sec() - static_stamps[0].to_sec() for s in static_stamps], '.')

    # poses = np.asarray(poses) - poses[0]
    # static_crystal_poses = np.asarray(static_crystal_poses) - static_crystal_poses[0]
    # plt.figure()
    # plt.plot(poses[:, 0], poses[:, 1], '.')
    # plt.plot(static_crystal_poses[:, 0], static_crystal_poses[:, 1], 'o')
    # plt.grid()
    # plt.axis('equal')
    # plt.show()

    # get corresponding static point clouds
    static_clouds = get_static_clouds(bag_path, static_stamps)
    print('Found %i static clouds' % len(static_clouds))

    assert len(static_clouds) == len(static_crystal_poses) == len(static_stamps)

    # create board mesh
    board_cloud = generate_board_cloud()
    board_cloud0 = board_cloud.copy()

    # transformation between ouster lidar and world frame (subt)
    Tr_base_subt = np.eye(4)
    Tr_base_subt[:3, 3] = -measurements['subt_base']

    # initial estimate
    Tr_subt_ouster = np.eye(4)
    Tr_subt_ouster[:3, :3] = Rotation.from_euler('z', 0.055, degrees=False).as_matrix()
    Tr_subt_ouster[:3, 3] = np.array([0, 0, -0.10])

    # find transformation between lidar and world frames from ICP alignment
    x = structured_to_unstructured(board_cloud[['x', 'y', 'z']])
    y = structured_to_unstructured(static_clouds[0][['x', 'y', 'z']])
    y = transform_cloud(y, Tr_base_subt)
    Tr_subt_ouster = icp_alignment(x, y, Tr_init=Tr_subt_ouster, inl_ratio=0.6, n_iters=50)
    print('Found transformation between lidar and world frames:\n%s\n' % Tr_subt_ouster)

    plt.figure(figsize=(21, 7))
    icp_dists = {'point_to_point': [], 'point_to_plane': []}
    icp_dists_corr = {'point_to_point': [], 'point_to_plane': []}
    board_angles = []
    for id in range(len(static_crystal_poses)):

        board_angle, board_normal = angle_from_leica(static_crystal_poses[id])
        board_angles.append(np.rad2deg(board_angle))

        # orient board cloud using tracked crystal pose
        Tr_base_board = np.eye(4)
        Tr_base_board[:3, :3] = Rotation.from_euler('z', board_angle, degrees=False).as_matrix()
        board_cloud = transform_cloud(board_cloud0, Tr_base_board)

        # transform ouster cloud to board base frame
        cloud = static_clouds[id]
        cloud = transform_cloud(cloud, Tr_base_subt @ Tr_subt_ouster)

        # filter board box from cloud
        box_scale = 0.4
        board_box_size = box_scale * np.array([board_length, board_length, board_height])
        cloud = filter_box(cloud, pose=np.asarray([0, 0, board_height / 2]), size=board_box_size)
        board_cloud = filter_box(board_cloud, pose=np.asarray([0, 0, board_height / 2]), size=board_box_size)

        # compute point cloud to mesh distance
        point_to_point = np.nan
        point_to_point_corr = np.nan
        point_to_plane = np.nan
        point_to_plane_corr = np.nan
        cloud_corr = cloud
        if len(cloud) > 0:
            # correction
            cloud_corr = correction(cloud, model, cfg)

            point_to_point, point_to_plane = eval(cloud, board_cloud, board_normal)
            point_to_point_corr, point_to_plane_corr = eval(cloud_corr, board_cloud, board_normal)

        icp_dists['point_to_point'].append(point_to_point)
        icp_dists['point_to_plane'].append(point_to_plane)
        icp_dists_corr['point_to_point'].append(point_to_point_corr)
        icp_dists_corr['point_to_plane'].append(point_to_plane_corr)

        # visualize_clouds([cloud, board_cloud])
        plt.subplot(1, 3, 1)
        plt.cla()
        plt.title('Board angle: %.1f [deg].' % np.rad2deg(board_angle))
        # plt.plot(cloud['x'], cloud['y'], '.', label='ouster cloud')
        plt.plot(cloud_corr['x'], cloud_corr['y'], '.', label='ouster cloud corrected')
        plt.plot(board_cloud['x'], board_cloud['y'], '.', label='gt cloud')
        plt.plot(0, 0, 'k+', markersize=10, label='origin')
        plt.legend()
        plt.xlim([-0.6, 0.6])
        plt.ylim([-0.6, 0.6])
        plt.xlabel('X [m]')
        plt.ylabel('Y [m]')
        plt.grid()

        plt.subplot(1, 3, 2)
        plt.cla()
        plt.title('ICP distance: %.3f' % point_to_point)
        plt.plot(board_angles, icp_dists['point_to_point'], '--', label='ICP distance')
        plt.plot(board_angles, icp_dists_corr['point_to_point'], label='ICP distance corrected')
        plt.legend()
        plt.grid()
        plt.xlabel('Board angle [deg]')
        plt.ylabel('ICP point to POINT distance [m]')

        plt.subplot(1, 3, 3)
        plt.cla()
        plt.title('ICP distance: %.3f' % point_to_plane)
        plt.plot(board_angles, icp_dists['point_to_plane'], '--', label='ICP distance')
        plt.plot(board_angles, icp_dists_corr['point_to_plane'], label='ICP distance corrected')
        plt.legend()
        plt.grid()
        plt.xlabel('Board angle [deg]')
        plt.ylabel('ICP point to PLANE distance [m]')

        plt.draw()
        plt.pause(0.5)

    plt.show()


def main():
    args = get_arg_parser().parse_args()

    kwargs = vars(args)
    for k in sorted(kwargs):
        print('%s: %s' % (k, kwargs[k]))

    bias_estimation()


if __name__ == '__main__':
    main()
