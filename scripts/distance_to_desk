#!/usr/bin/env python
from __future__ import absolute_import, division, print_function
from depth_correction.config import Config
from depth_correction.filters import filter_depth, filter_box
from ros_numpy import msgify, numpify
import rospy
from sensor_msgs.msg import PointCloud2
import numpy as np
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured
from visualization_msgs.msg import Marker
from geometry_msgs.msg import TransformStamped
import tf2_ros


def create_box_marker(p=None, q=None, scale=None):
    if scale is None:
        scale = [1, 1, 1]
    if q is None:
        q = [0, 0, 0, 1]
    if p is None:
        p = [0, 0, 0]
    marker = Marker()
    marker.type = Marker.CUBE
    marker.action = Marker.ADD
    marker.pose.position.x = p[0]
    marker.pose.position.y = p[1]
    marker.pose.position.z = p[2]
    marker.pose.orientation.x = q[0]
    marker.pose.orientation.y = q[1]
    marker.pose.orientation.z = q[2]
    marker.pose.orientation.w = q[3]
    marker.scale.x = scale[0]
    marker.scale.y = scale[1]
    marker.scale.z = scale[2]
    marker.color.a = 0.5
    marker.color.r = 0.0
    marker.color.g = 1.0
    marker.color.b = 0.0
    return marker

def create_sphere_marker(p=None, q=None, scale=None):
    if scale is None:
        scale = [1, 1, 1]
    if q is None:
        q = [0, 0, 0, 1]
    if p is None:
        p = [0, 0, 0]
    marker = Marker()
    marker.type = Marker.SPHERE
    marker.action = Marker.ADD
    marker.pose.position.x = p[0]
    marker.pose.position.y = p[1]
    marker.pose.position.z = p[2]
    marker.pose.orientation.x = q[0]
    marker.pose.orientation.y = q[1]
    marker.pose.orientation.z = q[2]
    marker.pose.orientation.w = q[3]
    marker.scale.x = scale[0]
    marker.scale.y = scale[1]
    marker.scale.z = scale[2]
    marker.color.a = 0.5
    marker.color.r = 0.0
    marker.color.g = 1.0
    marker.color.b = 0.0
    return marker


def compute_dist(cloud, pose_init, search_radius=0.3):
    """Estimate distance to a rectangular desk placed perpendicular to a lidar"""
    assert isinstance(cloud, np.ndarray)

    # size = [1.0, 1.0, 0.6]
    # keep = filter_box(cloud, pose_est, size, only_mask=True)
    # filtered = cloud[keep]
    # marker = create_box_marker(p=pose_est, scale=size)

    # estimate distance
    if cloud.dtype.names:
        pts = structured_to_unstructured(cloud[['x', 'y', 'z']])
    else:
        pts = cloud
    vps = np.full_like(pts, pose_init)

    xyzv = unstructured_to_structured(np.concatenate([pts, vps], axis=1), names=['x', 'y', 'z', 'vp_x', 'vp_y', 'vp_z'])
    keep = filter_depth(xyzv, min=0, max=search_radius, only_mask=True)
    filtered = cloud[keep]

    dist = pts[keep, 0].mean()
    rospy.loginfo('Estimated distance to desk: %f' % dist)

    marker = create_sphere_marker(p=pose_init, scale=[2 * search_radius, 2 * search_radius, 2 * search_radius])

    pose_est = [dist, pose_init[1], pose_init[2]]

    return pose_est, filtered, marker


class DeskDistance(object):

    def __init__(self):
        self.cfg = Config()
        cfg_path = rospy.get_param('~config', None)
        if cfg_path:
            self.cfg.from_yaml(cfg_path)
        self.cfg.from_rosparam()

        self.pose_init = [5.475, 0.0, 0.45]
        self.search_radius = rospy.get_param('~search_radius', 0.3)

        self.pub = rospy.Publisher('output', PointCloud2, queue_size=2)
        self.marker_pub = rospy.Publisher('~marker', Marker, queue_size=1)
        self.tf_br = tf2_ros.TransformBroadcaster()
        self.sub = rospy.Subscriber('input', PointCloud2, self.process, queue_size=2)

    def process(self, input_cloud_msg):
        assert isinstance(input_cloud_msg, PointCloud2)
        cloud = numpify(input_cloud_msg)
        if cloud.ndim == 2:
            cloud = cloud.reshape((-1,))

        pose_est, cloud, box_marker = compute_dist(cloud, self.pose_init, self.search_radius)

        output_msg = msgify(PointCloud2, cloud)
        output_msg.header = input_cloud_msg.header

        box_marker.header = input_cloud_msg.header

        # create and publish estimated desk pose as tf msg
        t = TransformStamped()

        t.header = input_cloud_msg.header
        t.child_frame_id = 'desk'
        t.transform.translation.x = pose_est[0]
        t.transform.translation.y = pose_est[1]
        t.transform.translation.z = pose_est[2]
        t.transform.rotation.x = 0
        t.transform.rotation.y = 0
        t.transform.rotation.z = 0
        t.transform.rotation.w = 1

        self.tf_br.sendTransform(t)

        self.pub.publish(output_msg)
        self.marker_pub.publish(box_marker)


def main():
    rospy.init_node('cloud_filter', log_level=rospy.INFO)
    node = DeskDistance()
    rospy.spin()


if __name__ == '__main__':
    main()
