#! /usr/bin/env python

from __future__ import absolute_import, division, print_function

import matplotlib.pyplot as plt
import torch
import numpy as np
from depth_correction.depth_cloud import DepthCloud
from depth_correction.loss import min_eigval_loss, trace_loss
from depth_correction.model import ScaledPolynomial, Polynomial
from depth_correction.filters import filter_depth, filter_grid, filter_eigenvalues
from numpy.lib.recfunctions import unstructured_to_structured
import rospy
from sensor_msgs.msg import PointCloud2
from ros_numpy import msgify
import tf
import time


N_pts = 8000
r_nn = 0.2
LR = 1e-4
grid_res = 0.05
PTS_HEIGHT = 1.2


def dc_to_msg(dc, stamp, frame='map'):
    cloud = DepthCloud.to_structured_array(dc)
    pc_msg = msgify(PointCloud2, cloud)
    pc_msg.header.frame_id = frame
    pc_msg.header.stamp = stamp
    return pc_msg


def main():
    rospy.init_node('depth_correction', anonymous=True)
    cloud_pub = rospy.Publisher('cloud', PointCloud2, queue_size=2)
    corrected_cloud_pub = rospy.Publisher('corrected_cloud', PointCloud2, queue_size=2)
    br = tf.TransformBroadcaster()

    # device = torch.device('cuda:0')
    device = torch.device('cpu')
    model = ScaledPolynomial().to(device)
    # model = Polynomial().to(device)

    optimizer = torch.optim.Adam(model.parameters(), lr=LR)

    # create flat point cloud (a wall)
    cloud1 = np.zeros((N_pts, 3), dtype=np.float32)
    cloud1[:, [0, 1]] = np.random.rand(N_pts, 2) * 10 - 5  # 10 x 10 m
    cloud1[:, 2] = PTS_HEIGHT
    vps1 = np.zeros_like(cloud1)

    dc_init1 = DepthCloud.from_points(cloud1, vps1)
    dc_init1.update_all(r=r_nn)
    # add disturbances
    p0, p1 = -0.03, -0.03
    gama = dc_init1.inc_angles
    dc_init1.depth = dc_init1.depth / (1 - (p0 * gama ** 2 + p1 * gama ** 4))

    cloud2 = np.zeros((N_pts, 3), dtype=np.float32)
    cloud2[:, [0, 1]] = np.random.rand(N_pts, 2) * 10 - 5  # 10 x 10 m
    cloud2[:, 2] = PTS_HEIGHT
    offset = np.asarray([4, 0, 0])
    cloud2 = cloud2 + offset
    vps2 = np.zeros_like(cloud2) + offset
    dc_init2 = DepthCloud.from_points(cloud2, vps2)
    dc_init2.update_all(r=r_nn)
    # add disturbances
    p0, p1 = -0.02, -0.04
    gama = dc_init1.inc_angles
    dc_init2.depth = dc_init2.depth / (1 - (p0 * gama ** 2 + p1 * gama ** 4))

    dc_init = DepthCloud.concatenate([dc_init1, dc_init2])
    dc_init.update_all(r=r_nn, keep_neighbors=False)

    # dc_init.visualize(colors='min_eigval', normals=True)

    # use model to correct the distortion (hopefully)
    loss0 = None
    plt.figure()
    losses = []
    metrics = []
    train_neighbors = None
    eigenvalue_bounds = [[0, None, (r_nn / 8) ** 2],
                         [1, (r_nn / 4) ** 2, None]]
    while True:
        if rospy.is_shutdown():
            break
        t0 = time.time()

        dc = model.correct_depth(dc_init)
        # dc.update_all(r=r_nn, keep_neighbors=dc.neighbors is not None)
        if train_neighbors is None:
            dc.update_all(r=r_nn)
            train_neighbors = dc.neighbors, dc.weights
            train_masks = filter_eigenvalues(dc, eig_bounds=eigenvalue_bounds, only_mask=True, log=False)
            print('Training on %.3f = %i / %i points.'
                  % (train_masks.float().mean().item(),
                     train_masks.sum().item(), train_masks.numel()))
        else:
            dc.neighbors, dc.weights = train_neighbors
            dc.update_all(r=r_nn, keep_neighbors=True)

        # loss, _ = min_eigval_loss(dc)
        loss, _ = trace_loss(dc)

        # Optimization step
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        # dc.update_all(r=r_nn)
        rospy.logdebug('Optimization step took %.3f sec' % (time.time()-t0))

        if not loss0:
            loss0 = loss
        losses.append(loss.item())
        # rospy.loginfo('loss - loss0 = %g' % (loss.item() - loss0.item()))
        # rospy.loginfo('Model parameters: p0=%f, p1=%f', model.p0.item(), model.p1.item())

        l2_loss1 = (np.linalg.norm(dc.points.detach()[N_pts, :] - cloud1)) / N_pts
        l2_loss2 = (np.linalg.norm(dc.points.detach()[N_pts:, :] - cloud2)) / N_pts
        l2_loss = (l2_loss1 + l2_loss2) / 2.
        metrics.append(l2_loss)

        # dc.visualize(colors='inc_angles', normals=True)
        stamp = rospy.Time.now()

        # publish point cloud msgs
        pc_init_msg = dc_to_msg(dc_init, stamp=stamp, frame='map')
        pc_msg = dc_to_msg(dc, stamp=stamp, frame='map')
        cloud_pub.publish(pc_init_msg)
        corrected_cloud_pub.publish(pc_msg)

        # publish viewpoints
        for i, vp in enumerate([dc_init1.vps[0], dc_init2.vps[0]]):
            br.sendTransform((vp[0], vp[1], vp[2]), (0, 0, 0, 1), time=stamp, child="vp_%d" % i, parent="map")

        # plot D vs gamma
        plt.subplot(1, 2, 1)
        plt.cla()
        # plt.plot(dc_init.depth.squeeze(), dc_init.inc_angles.squeeze(), '.', label='init cloud')
        # plt.plot(dc.depth.detach().squeeze(), dc.inc_angles.detach().squeeze(), '.', label='corrected cloud')
        # plt.legend()
        # plt.grid()
        # plt.xlabel('depth, [m]')
        # plt.ylabel('gamma, [rad]')
        plt.plot(metrics)
        plt.grid()
        plt.ylabel('l2 difference from gt')
        plt.xlabel('time, iters')

        plt.subplot(1, 2, 2)
        plt.cla()
        plt.plot(losses)
        plt.grid()
        plt.ylabel('loss')
        plt.xlabel('time, iters')

        plt.draw()
        plt.pause(0.01)


if __name__ == '__main__':
    main()
