#! /usr/bin/env python

import numpy as np
import torch
import open3d as o3d
from tqdm import tqdm
from matplotlib import pyplot as plt
from data.depth_correction import Dataset, dataset_names
from depth_correction.depth_cloud import DepthCloud
from depth_correction.model import ScaledPolynomial, Polynomial
from depth_correction.preproc import filtered_cloud
from depth_correction.config import Config
from depth_correction.loss import point_to_plane_dist, point_to_plane_loss


def select_clouds(ds, scan_n, cfg):
    points1_struct, pose1 = ds[scan_n]
    points2_struct, pose2 = ds[scan_n + 1]

    cloud1 = DepthCloud.from_structured_array(points1_struct)
    cloud2 = DepthCloud.from_structured_array(points2_struct)

    cloud1 = filtered_cloud(cloud1, cfg)
    cloud2 = filtered_cloud(cloud2, cfg)

    cloud1 = cloud1.transform(torch.as_tensor(pose1))
    cloud2 = cloud2.transform(torch.as_tensor(pose2))

    cloud1.update_all(r=cfg.nn_r)
    cloud2.update_all(r=cfg.nn_r)

    clouds = [cloud1, cloud2]
    return clouds


phi = np.deg2rad(50.8)
Rot = torch.as_tensor([[np.cos(phi), -np.sin(phi), 0],
                       [np.sin(phi), np.cos(phi), 0],
                       [0, 0, 1]])
def plot_clouds(ax, clouds, n_pts=5000, **kwargs):
    cloud = DepthCloud.concatenate(clouds)
    idx = np.unique(np.linspace(0, len(cloud) - 1, n_pts, dtype=int)).tolist()

    with torch.no_grad():
        pts = cloud.to_points()
        pts = pts[idx]
        pts = (Rot.to(pts.device) @ pts.T).T
        x = pts[:, 0].detach().cpu()
        y = pts[:, 1].detach().cpu()
        z = pts[:, 2].detach().cpu()
        mask = torch.logical_and(torch.logical_and(y > -4.0, y < 4.0), torch.logical_and(z > 0.1, z < 2.9))
        # mask = np.logical_and(z > 0.1, z < 2.9)
        x = x[mask]
        y = y[mask]

    ax.plot(x, y, 'b.', **kwargs)


def main():
    # ds = Dataset(name=dataset_names[0])
    ds = Dataset(name='slam_2022-11-24-15-28-59_step_1')

    cfg = Config()
    # cfg.min_depth = 1.0
    # cfg.max_depth = 25.0
    # cfg.grid_res = 0.2
    # cfg.nn_r = 0.4
    cfg.lr = 0.001
    cfg.device = 'cuda'
    # cfg.device = 'cpu'

    model = ScaledPolynomial(w=[0.0], exponent=[6])
    optimizer = torch.optim.Adam(model.parameters(), lr=cfg.lr)

    train_scan_id = int(np.random.choice(range(len(ds) - 1)))
    # train_scan_id = 8
    train_clouds = select_clouds(ds, scan_n=train_scan_id, cfg=cfg)

    val_scan_id = int(np.random.choice(range(len(ds) - 1)))
    val_clouds = select_clouds(ds, scan_n=val_scan_id, cfg=cfg)

    # put model and data on device
    model = model.to(cfg.device)
    train_clouds = [c.to(cfg.device) for c in train_clouds]
    val_clouds = [c.to(cfg.device) for c in val_clouds]

    fig, axes = plt.subplots(3, 2, figsize=(20.0, 10.0), constrained_layout=True, squeeze=False)
    fig.suptitle('ICP optimization')

    epochs = 200
    losses_train = []
    losses_val = []
    weights = []
    iters = []
    for i in tqdm(range(epochs)):
        train_clouds_corr = [model(c) for c in train_clouds]
        for c in train_clouds_corr:
            c.update_points()
        loss = point_to_plane_dist(clouds=train_clouds_corr, dist_th=cfg.grid_res)

        with torch.no_grad():
            val_clouds_corr = [model(c) for c in val_clouds]
            for c in val_clouds_corr:
                c.update_points()
            loss_val = point_to_plane_dist(clouds=val_clouds_corr, dist_th=cfg.grid_res)

        iters.append(i)
        losses_train.append(loss.item())
        losses_val.append(loss_val.item())
        weights.append(model.w.squeeze().item())

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        if i % 10 == 0:
            ax = axes[0, 0]
            ax.cla()
            ax.grid()
            ax.set_ylabel('ICP train loss: (%i, %i)' % (train_scan_id, train_scan_id + 1))
            ax.set_xlabel('Iterations')
            ax.plot(iters, losses_train, color='k')

            ax = axes[0, 1]
            ax.cla()
            ax.grid()
            ax.set_ylabel('ICP val loss: (%i, %i)' % (val_scan_id, val_scan_id + 1))
            ax.set_xlabel('Iterations')
            ax.plot(iters, losses_val, color='k')

            ax = axes[1, 0]
            ax.cla()
            plot_clouds(ax, train_clouds_corr, markersize=2)
            ax.set_xlabel('x [m]')
            ax.set_ylabel('y [m]')
            ax.set_ylim([-4.0, 4.0])
            # ax.set_aspect('equal')
            ax.grid()

            ax = axes[1, 1]
            ax.cla()
            plot_clouds(ax, val_clouds_corr, markersize=2)
            ax.set_xlabel('x [m]')
            ax.set_ylabel('y [m]')
            ax.set_ylim([-4.0, 4.0])
            # ax.set_aspect('equal')
            ax.grid()

            if cfg.device == 'cpu':
                ax = axes[2, 0]
                ax.cla()
                # TODO: check model.to and model.plot functions when device is CUDA
                model.plot(ax)
                ax.grid()
                ax.legend()

            ax = axes[2, 1]
            ax.cla()
            ax.grid()
            ax.set_ylabel("Model weight, w")
            ax.set_xlabel('Iterations')
            ax.plot(iters, weights, color='k')

            plt.pause(0.001)
            plt.draw()

    print(model)
    plt.show()


if __name__ == "__main__":
    main()
