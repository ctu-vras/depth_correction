#! /usr/bin/env python

from __future__ import absolute_import, division, print_function
import matplotlib.pyplot as plt
import torch
import numpy as np
from depth_correction.depth_cloud import DepthCloud
from depth_correction.loss import min_eigval_loss, trace_loss, l2_loss
from depth_correction.model import ScaledPolynomial, Polynomial
from depth_correction.filters import filter_eigenvalues, filter_grid
from depth_correction.preproc import filtered_cloud, local_feature_cloud
from depth_correction.config import Config
from data.semantic_kitti import Dataset
import rospy
from sensor_msgs.msg import PointCloud2
from ros_numpy import msgify
import tf
import time
import os
from matplotlib import cm
from copy import deepcopy
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured


class Optimization(object):
    def __init__(self):
        self.cloud_pub = rospy.Publisher('cloud', PointCloud2, queue_size=2)
        self.corrected_cloud_pub = rospy.Publisher('corrected_cloud', PointCloud2, queue_size=2)
        self.br = tf.TransformBroadcaster()
        self.device = torch.device(rospy.get_param('~device', 'cpu'))
        self.model = ScaledPolynomial() if rospy.get_param('~model',
                                                           'ScaledPolynomial') == 'ScaledPolynomial' else Polynomial()
        self.model = self.model.to(self.device)
        self.loss_fun = min_eigval_loss if rospy.get_param('~loss_fun',
                                                           'min_eigval_loss') == 'min_eigval_loss' else trace_loss
        self.vis = rospy.get_param('~plots', True)
        self.vis_clouds = rospy.get_param('~visualize_clouds', True)
        self.lr = rospy.get_param('~lr', 0.001)
        self.env_type = rospy.get_param('~env_type', 'simple_cave_01')
        self.n_pts = rospy.get_param('~n_pts', 100000)
        self.n_vps = rospy.get_param('~n_vps', 4)
        self.env_size = rospy.get_param('~env_size', 20)
        self.distor = {'p0': rospy.get_param('~p0_distor', -0.03),
                       'p1': rospy.get_param('~p1_distor', 0.0)}
        self.angle_degrees = rospy.get_param('~angle_degrees', 0.0)
        self.mesh_pts_to_sample = rospy.get_param('~pts_sampled_from_mesh', 10_000_000)
        self.cfg = Config()
        params_file = os.path.join(os.path.dirname(__file__), '..', 'config/gen/baseline_params.yaml')
        if os.path.exists(params_file):
            self.cfg.from_yaml(params_file)
        else:
            rospy.logwarn('Params file not found')
        if rospy.get_param('~monotonous_model', True):
            self.optimizer = torch.optim.Adam([self.model.p0], lr=self.lr)
        else:
            self.optimizer = torch.optim.Adam(self.model.parameters(), lr=self.lr)
        self.r_nn = rospy.get_param('~r_nn', 0.2)
        # self.eigenvalue_bounds = [[0, None, (self.r_nn / 8) ** 2],
        #                           [1, (self.r_nn / 4) ** 2, None]]
        self.eigenvalue_bounds = []
        self.l2_reg_weight = rospy.get_param('~l2_reg_weight', 0.0)
        if self.env_type == 'kitti':
            self.dc_init, self.pts_gt, self.vps, self.dc_offset = self.create_environment_from_kitti()
        else:
            self.dc_init, self.pts_gt, self.vps, self.dc_offset = self.create_environment()

        self.dc_init = self.dc_init.detach()

    @staticmethod
    def dc_to_msg(dc, stamp, frame='map', grid_res=0.5):
        # # colors = dc.eigvals.detach()[:, 0]
        # colors = dc.mask
        # cloud = DepthCloud.to_structured_array(dc, colors=dc.get_colors(colors, colormap=cm.viridis))
        dc = filter_grid(dc, grid_res=grid_res, keep='first')
        cloud = DepthCloud.to_structured_array(dc)
        pc_msg = msgify(PointCloud2, cloud)
        pc_msg.header.frame_id = frame
        pc_msg.header.stamp = stamp
        return pc_msg

    @staticmethod
    def add_distortion(dc, p0=-0.03, p1=0.0):
        gama = dc.inc_angles
        dc.depth = dc.depth / (1 - (p0 * gama ** 2 + p1 * gama ** 4))
        return dc

    @staticmethod
    def rotate_pts(p, origin=(0, 0, 0), degrees=0.0, axis='X'):
        angle = np.deg2rad(degrees)
        if axis == 'Z':
            R = np.array([[np.cos(angle), -np.sin(angle), 0],
                          [np.sin(angle), np.cos(angle), 0],
                          [0, 0, 1]])
        elif axis == 'Y':
            R = np.array([[np.cos(angle), 0, np.sin(angle)],
                          [0, 1, 0],
                          [-np.sin(angle), 0, np.cos(angle)]])
        elif axis == 'X':
            R = np.array([[1, 0, 0],
                          [0, np.cos(angle), -np.sin(angle)],
                          [0, np.sin(angle), np.cos(angle)]])
        o = np.atleast_3d(origin)
        p = np.atleast_3d(p)
        return np.squeeze((R @ (p.T - o.T) + o.T).T)

    def angle_point_cloud(self, n_pts=10000, size=10.0, degrees=0.0):
        # create flat point cloud (a wall)
        np.random.seed(135)
        pts_gt = np.zeros((n_pts, 3), dtype=np.float64)
        pts_gt[:, :2] = np.concatenate([np.random.uniform(0, size / 2, size=(n_pts // 2, 2)),
                                        np.random.uniform(0, size / 2, size=(n_pts // 2, 2)) + np.array(
                                            [-size / 2, 0])])
        # rotate half of the point cloud to create an angle
        if degrees != 0.0:
            rot_origin, rot_angle = (0, 0, 0), degrees
            pts_gt[n_pts // 2:] = self.rotate_pts(pts_gt[n_pts // 2:], origin=rot_origin, degrees=rot_angle, axis='Y')
        return pts_gt

    @staticmethod
    def point_cloud_from_mesh(mesh_name='simple_cave_01.obj', size=20.0, pts_to_sample=10_000_000):
        from pytorch3d.ops import sample_points_from_meshes
        from pytorch3d.io import load_obj, load_ply
        from pytorch3d.structures import Meshes

        mesh_path = os.path.join(os.path.dirname(__file__), '../data/meshes/%s' % mesh_name)

        if not os.path.exists(mesh_path):
            raise FileExistsError('Mesh file %s does not exist' % mesh_path)

        if mesh_path[-3:] == 'obj':
            pts_gt, faces, _ = load_obj(mesh_path)
            mesh = Meshes(verts=[pts_gt], faces=[faces.verts_idx])
        elif mesh_path[-3:] == 'ply':
            pts_gt, faces = load_ply(mesh_path)
            mesh = Meshes(verts=[pts_gt], faces=[faces])
        else:
            raise ValueError('Supported mesh formats are *.obj or *.ply')

        torch.random.manual_seed(135)
        pts_gt = sample_points_from_meshes(mesh, pts_to_sample).squeeze().numpy()
        X, Y, Z = pts_gt[:, 0], pts_gt[:, 1], pts_gt[:, 2]
        pts_gt = pts_gt[np.logical_and(np.logical_and(np.logical_and(X >= -size / 2, X <= size / 2),
                                                      np.logical_and(Y >= -size / 2, Y <= size / 2)),
                                       np.logical_and(Z >= -1.0, Z <= 4))]
        n_pts = len(pts_gt)
        rospy.loginfo('Number of points sampled and filtered from mesh: %d' % n_pts)
        return pts_gt

    def create_environment_from_kitti(self, name='04_start_111_end_113_step_1'):
        try:
            ds = Dataset(name, pose_provider='odom')
        except:
            rospy.logwarn('Using SuMa SLAM poses for Semantic KITTI sequence %s' % name)
            ds = Dataset(name, pose_provider='surf_slam')

        dcs_list = []
        vps_list = []
        poses = []
        for pts, pose in ds:
            dc = filtered_cloud(pts, self.cfg)
            dc = local_feature_cloud(dc, self.cfg)
            dcs_list.append(dc)
            poses.append(torch.as_tensor(pose))
            vps_list.append(pose[:3, 3])

        dcs_transformed_list = []
        for i, dc1 in enumerate(dcs_list):
            dc1 = dc1.transform(poses[i])
            dc1.update_all(r=self.r_nn)

            dcs_transformed_list.append(dc1)
        dc = DepthCloud.concatenate(dcs_transformed_list, fields=['vps', 'dirs', 'depth', 'cov', 'eigvals'],
                                    dependent=False)
        dc_offset = dc.copy()
        dc.update_all(r=self.r_nn)

        # pts_gt = None
        pts_gt = dc.get_points()

        dc = self.add_distortion(dc, p0=self.distor['p0'], p1=self.distor['p1'])
        dc.update_all(r=self.r_nn)

        dc.mask = filter_eigenvalues(dc, eig_bounds=self.eigenvalue_bounds, only_mask=True, log=True)

        return dc, pts_gt, vps_list, dc_offset

    def create_environment(self):
        if self.env_type == 'angle':
            pts = self.angle_point_cloud(n_pts=self.n_pts, size=self.env_size,
                                         degrees=self.angle_degrees)
        else:
            pts = self.point_cloud_from_mesh(mesh_name=self.env_type, size=self.env_size,
                                             pts_to_sample=self.mesh_pts_to_sample)
            self.n_pts = len(pts)
        dcs_list = []
        pts_list = []
        vps_list = []
        np.random.seed(135)
        for n in range(self.n_vps):
            pts1 = pts[np.random.choice(range(self.n_pts), self.n_pts // self.n_vps)]

            vps1 = deepcopy(pts1[np.random.choice(range(len(pts1)))])
            vps1[2] += np.random.uniform(0.1, 2.)

            dc1 = DepthCloud.from_points(pts1, vps=vps1 + np.zeros_like(pts1))
            dc1.update_all(r=self.r_nn)

            pts_list.append(pts1)
            vps_list.append(vps1)
            dcs_list.append(dc1)

        pts = np.concatenate(pts_list, axis=0)
        dc = DepthCloud.concatenate(dcs_list, fields=['vps', 'dirs', 'depth', 'cov', 'eigvals'], dependent=False)

        dc_offset = dc.copy()
        dc.update_all(r=self.r_nn)

        dc = self.add_distortion(dc, p0=self.distor['p0'], p1=self.distor['p1'])
        dc.update_all(r=self.r_nn)

        dc.mask = filter_eigenvalues(dc, eig_bounds=self.eigenvalue_bounds, only_mask=True, log=True)

        return dc, pts, vps_list, dc_offset

    def run(self):
        plt.figure()
        losses = []
        l2_metrics = []
        train_neighbors = deepcopy((self.dc_init.neighbors, self.dc_init.weights))

        while True:
            if rospy.is_shutdown():
                break
            t0 = time.time()

            # use model to correct the distortion (hopefully)
            dc = self.model(self.dc_init)

            dc.neighbors, dc.weights = train_neighbors
            dc.update_all(keep_neighbors=True)

            loss_correction, _ = self.loss_fun(dc, offset=self.dc_offset)

            l2_regularization = l2_loss(dc, self.dc_init)
            rospy.logdebug('L2 loss from original (not corrected) cloud: %g' % l2_regularization)
            loss = loss_correction + self.l2_reg_weight * l2_regularization

            # Optimization step
            if rospy.get_param('~backprop', True):
                self.optimizer.zero_grad()
                loss.backward()
                self.optimizer.step()
                rospy.logdebug('Optimization step took %.3f sec' % (time.time() - t0))

            loss = loss.detach()
            losses.append(loss.item())
            rospy.loginfo('%s = %g' % (rospy.get_param('~loss_fun', 'loss'), loss.item()))
            rospy.logdebug('Model parameters: p0=%f, p1=%f', self.model.p0.item(), self.model.p1.item())

            if self.pts_gt is not None:
                l2_metric = torch.linalg.norm(dc.points.detach() - self.pts_gt) / len(self.pts_gt)
                l2_metrics.append(l2_metric)
                rospy.logdebug('L2 difference from ground truth: %g' % l2_metric)

            # publish point cloud msgs
            t0 = time.time()
            stamp = rospy.Time.now()
            pc_init_msg = self.dc_to_msg(self.dc_init, stamp=stamp, frame='map')
            pc_msg = self.dc_to_msg(dc, stamp=stamp, frame='map')
            self.cloud_pub.publish(pc_init_msg)
            self.corrected_cloud_pub.publish(pc_msg)

            # publish viewpoints
            for i, vp in enumerate(self.vps):
                self.br.sendTransform((vp[0], vp[1], vp[2]), (0, 0, 0, 1), time=stamp, child="vp_%d" % i, parent="map")
            rospy.logdebug('Data publishing took %.3f sec' % (time.time() - t0))

            # visualization
            if self.vis:
                t0 = time.time()
                self.visualize(l2_metrics, losses, dc, map_step=32)
                rospy.logdebug('Visualization took: %.3f' % (time.time() - t0))

    def visualize(self, l2_metrics, losses, dc, map_step=1):
        np.random.seed(135)

        plt.subplot(2, 2, 1)
        plt.cla()
        plt.plot(l2_metrics)
        plt.grid()
        plt.ylabel('L2 difference from gt')
        plt.xlabel('time, iters')

        plt.subplot(2, 2, 2)
        plt.cla()
        plt.plot(losses)
        plt.grid()
        plt.ylabel(rospy.get_param('~loss_fun', 'loss') + '+ l2_regularization')
        plt.xlabel('time, iters')

        if self.vis_clouds:
            plt.subplot(2, 2, 3)
            plt.cla()

            pts_to_plot = self.dc_init.points.detach().squeeze()
            idxs = np.random.choice(range(len(pts_to_plot)), len(pts_to_plot) // map_step)
            pts_to_plot = pts_to_plot[idxs]
            plt.plot(pts_to_plot[:, 1], pts_to_plot[:, 2], '.', label='Z initial', color='r')

            if self.pts_gt is not None:
                pts_to_plot = self.pts_gt
                pts_to_plot = pts_to_plot[idxs]
                plt.plot(pts_to_plot[:, 1], pts_to_plot[:, 2], '.', label='Z gt')

            pts_to_plot = dc.points.detach().squeeze()
            pts_to_plot = pts_to_plot[idxs]
            plt.plot(pts_to_plot[:, 1], pts_to_plot[:, 2], '.', label='Z corrected', color='g')

            plt.grid()
            plt.ylabel('Z, [m]')
            plt.xlabel('Y, [m]')
            plt.legend()
            if self.env_type == 'kitti':
                plt.axis('equal')

            plt.subplot(2, 2, 4)
            plt.cla()

            pts_to_plot = self.dc_init.points.detach().squeeze()
            idxs = np.random.choice(range(len(pts_to_plot)), len(pts_to_plot) // map_step)
            pts_to_plot = pts_to_plot[idxs]
            plt.plot(pts_to_plot[:, 0], pts_to_plot[:, 2], '.', label='Z initial', color='r')

            if self.pts_gt is not None:
                pts_to_plot = self.pts_gt
                pts_to_plot = pts_to_plot[idxs]
                plt.plot(pts_to_plot[:, 0], pts_to_plot[:, 2], '.', label='Z gt')

            pts_to_plot = dc.points.detach().squeeze()
            pts_to_plot = pts_to_plot[idxs]
            plt.plot(pts_to_plot[:, 0], pts_to_plot[:, 2], '.', label='Z corrected', color='g')

            plt.grid()
            plt.ylabel('Z, [m]')
            plt.xlabel('X, [m]')
            plt.legend()
            if self.env_type == 'kitti':
                plt.axis('equal')

        plt.draw()
        plt.pause(0.01)


def main():
    rospy.init_node('depth_correction', anonymous=True, log_level=rospy.DEBUG)
    opt = Optimization()
    opt.run()


if __name__ == '__main__':
    main()
