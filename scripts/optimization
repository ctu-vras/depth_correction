#! /usr/bin/env python

from __future__ import absolute_import, division, print_function
import matplotlib.pyplot as plt
import torch
import numpy as np
from depth_correction.depth_cloud import DepthCloud
from depth_correction.loss import loss_by_name, l2_loss
from depth_correction.model import model_by_name
from depth_correction.filters import filter_eigenvalues, filter_grid
from depth_correction.preproc import filtered_cloud, local_feature_cloud
from depth_correction.config import Config
import rospy
from sensor_msgs.msg import PointCloud2
from ros_numpy import msgify
import tf
import time
import os
from matplotlib import cm
from copy import deepcopy
from numpy.lib.recfunctions import structured_to_unstructured, unstructured_to_structured


class Optimization(object):
    def __init__(self):
        self.cloud_pub = rospy.Publisher('cloud', PointCloud2, queue_size=2)
        self.corrected_cloud_pub = rospy.Publisher('corrected_cloud', PointCloud2, queue_size=2)
        self.br = tf.TransformBroadcaster()
        self.device = torch.device(rospy.get_param('~device', 'cpu'))
        self.model = model_by_name(rospy.get_param('~model', 'ScaledPolynomial'))(w=[0.0], exponent=[2]).to(self.device)
        self.loss_fun = loss_by_name(rospy.get_param('~loss_fun', 'min_eigval_loss'))
        self.vis = rospy.get_param('~plots', True)
        self.vis_clouds = rospy.get_param('~visualize_clouds', True)
        self.lr = rospy.get_param('~lr', 0.001)
        self.env_type = rospy.get_param('~env_type', 'angle')
        self.n_pts = rospy.get_param('~n_pts', 100000)
        self.n_vps = rospy.get_param('~n_vps', 4)
        self.env_size = rospy.get_param('~env_size', 20)
        self.distorion_model = model_by_name(rospy.get_param('~model', 'ScaledPolynomial'))(w=[-0.03], exponent=[2]).to(self.device)
        self.angle_degrees = rospy.get_param('~angle_degrees', 0.0)
        self.mesh_pts_to_sample = rospy.get_param('~pts_sampled_from_mesh', 10_000_000)
        self.cfg = Config()
        params_file = os.path.join(os.path.dirname(__file__), '..', 'config/gen/baseline_params.yaml')
        if os.path.exists(params_file):
            self.cfg.from_yaml(params_file)
        else:
            rospy.logwarn('Params file not found')
        self.optimizer = torch.optim.Adam(self.model.parameters(), lr=self.lr)
        self.r_nn = rospy.get_param('~r_nn', 0.2)
        # self.eigenvalue_bounds = [[0, None, (self.r_nn / 8) ** 2],
        #                           [1, (self.r_nn / 4) ** 2, None]]
        self.eigenvalue_bounds = []
        self.l2_reg_weight = rospy.get_param('~l2_reg_weight', 0.0)
        self.dc_init, self.pts_gt, self.vps, self.dc_offset = self.create_environment()

        self.dc_init = self.dc_init.detach()

    @staticmethod
    def dc_to_msg(dc, stamp, frame='map', grid_res=0.5):
        # # colors = dc.eigvals.detach()[:, 0]
        # colors = dc.mask
        # cloud = DepthCloud.to_structured_array(dc, colors=dc.get_colors(colors, colormap=cm.viridis))
        dc = filter_grid(dc, grid_res=grid_res, keep='first')
        cloud = DepthCloud.to_structured_array(dc)
        pc_msg = msgify(PointCloud2, cloud)
        pc_msg.header.frame_id = frame
        pc_msg.header.stamp = stamp
        return pc_msg

    def create_environment(self):
        if self.env_type == 'angle':
            from depth_correction.dataset import AngleDataset
            ds = AngleDataset(n_pts=self.n_pts, n_poses=self.n_vps, size=self.env_size, degrees=self.angle_degrees)
        elif self.env_type == 'kitti':
            from data.semantic_kitti import Dataset
            name = '04_start_111_end_113_step_1'
            try:
                ds = Dataset(name, pose_provider='odom')
            except:
                rospy.logwarn('Using SuMa SLAM poses for Semantic KITTI sequence %s' % name)
                ds = Dataset(name, pose_provider='surf_slam')
        elif '.obj' in self.env_type or '.ply' in self.env_type:
            from depth_correction.dataset import MeshDataset
            ds = MeshDataset(mesh_name=self.env_type, n_pts=self.n_pts, n_poses=self.n_vps, size=self.env_size)
            self.n_pts = len(ds.global_cloud)
        else:
            raise ValueError('Unknown dataset: %s.' % self.env_type)

        dcs_list = []
        vps_list = []
        poses = []
        for i in range(len(ds)):
            pts, pose = ds[i]
            dc = filtered_cloud(pts, self.cfg)
            dc = local_feature_cloud(dc, self.cfg)
            dcs_list.append(dc)
            poses.append(torch.as_tensor(pose))
            vps_list.append(pose[:3, 3])

        dcs_transformed_list = []
        for i, dc1 in enumerate(dcs_list):
            dc1 = dc1.transform(poses[i])
            dc1.update_all(r=self.r_nn)

            dcs_transformed_list.append(dc1)
        dc = DepthCloud.concatenate(dcs_transformed_list, fields=['vps', 'dirs', 'depth', 'cov', 'eigvals'],
                                    dependent=False)
        dc_offset = dc.copy()
        dc.update_all(r=self.r_nn)

        # pts_gt = None
        pts_gt = dc.get_points()

        dc = self.distorion_model.inverse(dc)
        dc.update_all(r=self.r_nn)

        dc.mask = filter_eigenvalues(dc, eig_bounds=self.eigenvalue_bounds, only_mask=True, log=True)

        return dc, pts_gt, vps_list, dc_offset

    def run(self):
        plt.figure()
        losses = []
        l2_metrics = []
        train_neighbors = deepcopy((self.dc_init.neighbors, self.dc_init.weights))

        while True:
            if rospy.is_shutdown():
                break
            t0 = time.time()

            # use model to correct the distortion (hopefully)
            dc = self.model(self.dc_init)

            dc.neighbors, dc.weights = train_neighbors
            dc.update_all(keep_neighbors=True)

            loss_correction, _ = self.loss_fun(dc, offset=self.dc_offset)

            l2_regularization = l2_loss(dc, self.dc_init)
            rospy.logdebug('L2 loss from original (not corrected) cloud: %g' % l2_regularization)
            loss = loss_correction + self.l2_reg_weight * l2_regularization

            # Optimization step
            if rospy.get_param('~backprop', True):
                self.optimizer.zero_grad()
                loss.backward()
                self.optimizer.step()
                rospy.logdebug('Optimization step took %.3f sec' % (time.time() - t0))

            loss = loss.detach()
            losses.append(loss.item())
            rospy.loginfo('%s = %g' % (rospy.get_param('~loss_fun', 'loss'), loss.item()))
            rospy.logdebug('Model parameters: p0=%f' % self.model.w.flatten()[0].item())

            if self.pts_gt is not None:
                l2_metric = torch.linalg.norm(dc.points.detach() - self.pts_gt) / len(self.pts_gt)
                l2_metrics.append(l2_metric)
                rospy.logdebug('L2 difference from ground truth: %g' % l2_metric)

            # publish point cloud msgs
            t0 = time.time()
            stamp = rospy.Time.now()
            pc_init_msg = self.dc_to_msg(self.dc_init, stamp=stamp, frame='map')
            pc_msg = self.dc_to_msg(dc, stamp=stamp, frame='map')
            self.cloud_pub.publish(pc_init_msg)
            self.corrected_cloud_pub.publish(pc_msg)

            # publish viewpoints
            for i, vp in enumerate(self.vps):
                self.br.sendTransform((vp[0], vp[1], vp[2]), (0, 0, 0, 1), time=stamp, child="vp_%d" % i, parent="map")
            rospy.logdebug('Data publishing took %.3f sec' % (time.time() - t0))

            # visualization
            if self.vis:
                t0 = time.time()
                self.visualize(l2_metrics, losses, dc, map_step=32)
                rospy.logdebug('Visualization took: %.3f' % (time.time() - t0))

    def visualize(self, l2_metrics, losses, dc, map_step=1):
        np.random.seed(135)

        plt.subplot(2, 2, 1)
        plt.cla()
        plt.plot(l2_metrics)
        plt.grid()
        plt.ylabel('L2 difference from gt')
        plt.xlabel('time, iters')

        plt.subplot(2, 2, 2)
        plt.cla()
        plt.plot(losses)
        plt.grid()
        plt.ylabel(rospy.get_param('~loss_fun', 'loss') + '+ l2_regularization')
        plt.xlabel('time, iters')

        if self.vis_clouds:
            plt.subplot(2, 2, 3)
            plt.cla()

            pts_to_plot = self.dc_init.points.detach().squeeze()
            idxs = np.random.choice(range(len(pts_to_plot)), len(pts_to_plot) // map_step)
            pts_to_plot = pts_to_plot[idxs]
            plt.plot(pts_to_plot[:, 1], pts_to_plot[:, 2], '.', label='Z initial', color='r')

            if self.pts_gt is not None:
                pts_to_plot = self.pts_gt
                pts_to_plot = pts_to_plot[idxs]
                plt.plot(pts_to_plot[:, 1], pts_to_plot[:, 2], '.', label='Z gt')

            pts_to_plot = dc.points.detach().squeeze()
            pts_to_plot = pts_to_plot[idxs]
            plt.plot(pts_to_plot[:, 1], pts_to_plot[:, 2], '.', label='Z corrected', color='g')

            plt.grid()
            plt.ylabel('Z, [m]')
            plt.xlabel('Y, [m]')
            plt.legend()
            if self.env_type == 'kitti':
                plt.axis('equal')

            plt.subplot(2, 2, 4)
            plt.cla()

            pts_to_plot = self.dc_init.points.detach().squeeze()
            idxs = np.random.choice(range(len(pts_to_plot)), len(pts_to_plot) // map_step)
            pts_to_plot = pts_to_plot[idxs]
            plt.plot(pts_to_plot[:, 0], pts_to_plot[:, 2], '.', label='Z initial', color='r')

            if self.pts_gt is not None:
                pts_to_plot = self.pts_gt
                pts_to_plot = pts_to_plot[idxs]
                plt.plot(pts_to_plot[:, 0], pts_to_plot[:, 2], '.', label='Z gt')

            pts_to_plot = dc.points.detach().squeeze()
            pts_to_plot = pts_to_plot[idxs]
            plt.plot(pts_to_plot[:, 0], pts_to_plot[:, 2], '.', label='Z corrected', color='g')

            plt.grid()
            plt.ylabel('Z, [m]')
            plt.xlabel('X, [m]')
            plt.legend()
            if self.env_type == 'kitti':
                plt.axis('equal')

        plt.draw()
        plt.pause(0.01)


def main():
    rospy.init_node('depth_correction', anonymous=True, log_level=rospy.DEBUG)
    opt = Optimization()
    opt.run()


if __name__ == '__main__':
    main()
