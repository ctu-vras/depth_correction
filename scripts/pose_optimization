#!/usr/bin/env python

from __future__ import absolute_import, division, print_function

import os
from depth_correction.filters import *
from depth_correction.model import *
from depth_correction.utils import timing
from depth_correction.loss import min_eigval_loss
from data.asl_laser import Dataset, dataset_names
from ros_numpy import msgify, numpify
import rospy
from rospkg import RosPack
from sensor_msgs.msg import PointCloud2
from geometry_msgs.msg import Pose, PoseStamped, Quaternion, Point
from std_msgs.msg import Header
from nav_msgs.msg import Path
import torch
from torch.utils.tensorboard import SummaryWriter
from timeit import default_timer as timer
from pytorch3d.transforms import (axis_angle_to_matrix,
                                  matrix_to_quaternion,
                                  quaternion_to_axis_angle,
                                  axis_angle_to_quaternion)
from tqdm import tqdm


def dc_to_ros_msg(dc, frame_id, stamp):
    pc_msg = msgify(PointCloud2, dc.to_structured_array())
    pc_msg.header.frame_id = frame_id
    pc_msg.header.stamp = stamp
    return pc_msg


def xyz_axis_angle_to_matrix(xyz_axis_angle):
    assert isinstance(xyz_axis_angle, torch.Tensor)
    assert xyz_axis_angle.shape[-1] == 6

    mat = torch.zeros(xyz_axis_angle.shape[:-1] + (4, 4), dtype=xyz_axis_angle.dtype, device=xyz_axis_angle.device)
    mat[..., :3, :3] = axis_angle_to_matrix(xyz_axis_angle[..., 3:])
    # for i in range(mat.shape[0]):
    #     mat[i] = torch.from_numpy(euler_matrix(axes='sxyz', *xyzrpy[i, 3:].detach().numpy()))
    mat[..., :3, 3] = xyz_axis_angle[..., :3]
    mat[..., 3, 3] = 1.
    assert mat.shape == xyz_axis_angle.shape[:-1] + (4, 4)
    # assert mat.shape[-2:] == (4, 4)
    return mat


def matrix_to_xyz_axis_angle(T):
    assert isinstance(T, torch.Tensor)
    assert T.dim() == 3
    assert T.shape[1:] == (4, 4)
    n_poses = len(T)
    q = matrix_to_quaternion(T[:, :3, :3])
    axis_angle = quaternion_to_axis_angle(q)
    xyz = T[:, :3, 3]
    poses = torch.concat([xyz, axis_angle], dim=1)
    assert poses.shape == (n_poses, 6)
    return poses


def xyz_axis_angle_to_pose_msg(xyz_axis_angle):
    # assert isinstance(xyz_axis_angle, torch.Tensor)
    # assert isinstance(xyz_axis_angle, list)
    q = axis_angle_to_quaternion(xyz_axis_angle[3:])
    msg = Pose(Point(*xyz_axis_angle[:3]), Quaternion(w=q[0], x=q[1], y=q[2], z=q[3]))
    return msg


# @timing
def xyz_axis_angle_to_path_msg(xyz_axis_angle, frame_id, stamp):
    assert isinstance(xyz_axis_angle, torch.Tensor)
    assert xyz_axis_angle.dim() == 2
    assert xyz_axis_angle.shape[-1] == 6
    xyz_axis_angle = xyz_axis_angle.detach()
    msg = Path()
    msg.poses = [PoseStamped(Header(), xyz_axis_angle_to_pose_msg(p)) for p in xyz_axis_angle]
    msg.header.frame_id = frame_id
    msg.header.stamp = stamp
    return msg


class PoseOptimizer(object):
    def __init__(self):
        self.device = torch.device(rospy.get_param('~device', 'cpu'))
        self.lr = rospy.get_param('~lr', 0.001)
        self.dataset_name = rospy.get_param('~dataset_name', dataset_names[0])
        self.ds = Dataset(self.dataset_name)
        self.step = rospy.get_param('~step', 5)
        self.n_iters = rospy.get_param('~n_iters', 100)

        self.max_age = rospy.get_param('~max_age', 1.0)
        self.r_nn = rospy.get_param('~r_nn', 0.15)
        self.min_depth = rospy.get_param('~min_depth', 1.0)
        self.max_depth = rospy.get_param('~max_depth', 10.0)
        self.grid_res = rospy.get_param('~grid_res', 0.05)
        self.eigenvalue_bounds = rospy.get_param('~eigenvalue_bounds', (0.0, 0.05 ** 2))

        self.world_frame = rospy.get_param('~world_frame', 'world')
        self.poses_pub = rospy.Publisher('poses', Path, queue_size=2)
        self.poses_opt_pub = rospy.Publisher('poses_opt', Path, queue_size=2)
        self.dc_pub = rospy.Publisher('global_cloud', PointCloud2, queue_size=2)
        self.dc_opt_pub = rospy.Publisher('global_cloud_opt', PointCloud2, queue_size=2)

    # @timing
    def construct_global_map(self, ds: Dataset, poses: torch.Tensor) -> DepthCloud:
        assert poses.dim() == 3
        assert poses.shape[1:] == (4, 4)
        clouds = []
        for id in tqdm(self.ds.ids[::5]):
            cloud = self.ds.local_cloud(id)
            pose = poses[id]

            t = timer()
            dc = DepthCloud.from_points(cloud)
            rospy.logdebug('%i points read from dataset %s, (%.3f s).'
                           % (dc.size(), ds.name, timer() - t))  # ~0.06 sec for 180000 pts

            # grid and depth filters
            t = timer()
            dc = filter_depth(dc, min=self.min_depth, max=self.max_depth, log=False)
            rospy.logdebug('%i points kept by depth filter with min_depth %.2f, max_depth %.2f m (%.3f s).'
                           % (dc.size(), self.min_depth, self.max_depth, timer() - t))  # ~0.002 sec

            t = timer()
            dc = filter_grid(dc, self.grid_res, keep='last')
            rospy.logdebug('%i points kept by grid filter with res. %.2f m (%.3f s).'
                           % (dc.size(), self.grid_res, timer() - t))  # ~0.1 sec

            t = timer()
            pose = pose.to(self.device)
            dc = dc.to(self.device)
            rospy.logdebug('moved poses and depth cloud to device (%.3f s).' % (timer() - t))  # ~0.001 sec

            t = timer()
            dc = dc.transform(pose)
            rospy.logdebug('transformed depth cloud to global frame (%.3f s).' % (timer() - t))  # ~0.001 sec

            # eigenvalues filter and depth correction with model
            t = timer()
            dc.update_all(r=self.r_nn)
            rospy.logdebug('update_all took (%.3f s).' % (timer() - t))  # ~2.0 sec on CPU and ~7.5 sec on GPU (!)

            t = timer()
            keep = filter_eigenvalue(dc, 0, max=(self.grid_res / 5) ** 2, only_mask=True, log=False)
            keep = keep & filter_eigenvalue(dc, 1, min=self.grid_res ** 2, only_mask=True, log=False)
            dc = dc[keep]
            dc.update_all(r=self.r_nn)
            rospy.logdebug('filtering eigvals and update_all took (%.3f s).'
                           % (timer() - t))  # ~1.0 sec on CPU and 3.2 sec on GPU (!)

            clouds.append(dc)

        dc_combined = DepthCloud.concatenate(clouds, True)
        return dc_combined

    def run(self):
        rospy.loginfo('Pose optimization started')

        Ts = []
        for _, pose in self.ds:
            Ts.append(torch.as_tensor(pose[None]))
        n_poses = len(Ts)
        Ts = torch.concat(Ts, dim=0)
        assert Ts.shape == (n_poses, 4, 4)

        poses_corr = torch.zeros((n_poses, 6), dtype=Ts.dtype)  # x, y, z, *axis_angle
        assert poses_corr.shape == (n_poses, 6)

        poses_corr.requires_grad = True

        # Initialize optimizer
        optimizer = torch.optim.Adam([poses_corr], lr=self.lr)

        pc_msg = None
        path_msg = None
        for i in range(self.n_iters):
            optimizer.zero_grad()

            if rospy.is_shutdown():
                break

            poses_corr_Ts = xyz_axis_angle_to_matrix(poses_corr)
            poses = torch.matmul(Ts, poses_corr_Ts)
            dc_opt_global = self.construct_global_map(self.ds, poses)

            # dc_opt_global.visualize()

            train_loss, _ = min_eigval_loss(dc_opt_global, r=self.r_nn, offset=True,
                                            eigenvalue_bounds=self.eigenvalue_bounds)
            rospy.loginfo('iter N %d, train loss: %g' % (i, train_loss.item()))

            # publish poses and clouds
            stamp = rospy.Time.now()
            pc_opt_msg = dc_to_ros_msg(dc_opt_global, frame_id=self.world_frame, stamp=stamp)
            path_opt_msg = xyz_axis_angle_to_path_msg(matrix_to_xyz_axis_angle(poses),
                                                      frame_id=self.world_frame, stamp=stamp)
            if i == 0:
                pc_msg = pc_opt_msg
                path_msg = path_opt_msg
            self.dc_pub.publish(pc_msg)
            self.dc_opt_pub.publish(pc_opt_msg)

            self.poses_pub.publish(path_msg)
            self.poses_opt_pub.publish(path_opt_msg)

            # optimization step
            train_loss.backward()
            optimizer.step()


def main():
    rospy.init_node('pose_optimization', log_level=rospy.INFO)
    pose_opt = PoseOptimizer()
    pose_opt.run()
    rospy.spin()


if __name__ == '__main__':
    main()
