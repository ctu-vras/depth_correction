#!/usr/bin/env python

from __future__ import absolute_import, division, print_function

import os
from depth_correction.filters import *
from depth_correction.model import *
from depth_correction.utils import timing
from depth_correction.loss import min_eigval_loss
from data.asl_laser import Dataset, dataset_names
from ros_numpy import msgify, numpify
import rospy
from rospkg import RosPack
from sensor_msgs.msg import PointCloud2
import torch
from torch.utils.tensorboard import SummaryWriter
from timeit import default_timer as timer
from pytorch3d.transforms import euler_angles_to_matrix, matrix_to_euler_angles
from tqdm import tqdm


def dc_to_ros_msg(dc, frame_id, stamp):
    pc_msg = msgify(PointCloud2, dc.to_structured_array())
    pc_msg.header.frame_id = frame_id
    pc_msg.header.stamp = stamp
    return pc_msg


def xyzrpy_matrix(xyzrpy):
    assert isinstance(xyzrpy, torch.Tensor)
    assert xyzrpy.shape[-1] == 6

    mat = torch.zeros(xyzrpy.shape[:-1] + (4, 4), dtype=xyzrpy.dtype, device=xyzrpy.device)
    mat[..., :3, :3] = euler_angles_to_matrix(xyzrpy[..., 3:], convention='XYZ')
    # for i in range(mat.shape[0]):
    #     mat[i] = torch.from_numpy(euler_matrix(axes='sxyz', *xyzrpy[i, 3:].detach().numpy()))
    mat[..., :3, 3] = xyzrpy[..., :3]
    mat[..., 3, 3] = 1.
    assert mat.shape == xyzrpy.shape[:-1] + (4, 4)
    # assert mat.shape[-2:] == (4, 4)
    return mat


class PoseOptimizer(object):
    def __init__(self):
        self.device = torch.device(rospy.get_param('~device', 'cpu'))
        self.lr = rospy.get_param('~lr', 0.001)
        self.dataset_name = rospy.get_param('~dataset_name', dataset_names[0])
        self.ds = Dataset(self.dataset_name)
        self.step = rospy.get_param('~step', 5)
        self.n_iters = rospy.get_param('~n_iters', 100)

        self.max_age = rospy.get_param('~max_age', 1.0)
        self.r_nn = rospy.get_param('~r_nn', 0.15)
        self.min_depth = rospy.get_param('~min_depth', 1.0)
        self.max_depth = rospy.get_param('~max_depth', 10.0)
        self.grid_res = rospy.get_param('~grid_res', 0.05)
        self.eigenvalue_bounds = rospy.get_param('~eigenvalue_bounds', (0.0, 0.05 ** 2))

        self.world_frame = rospy.get_param('~world_frame', 'world')
        # self.initial_dcs_timer = rospy.Timer(rospy.Duration(3), self.publish_init_clouds())

    @timing
    def construct_global_map(self, ds: Dataset, xyzrpy: torch.Tensor) -> DepthCloud:
        clouds = []
        for id in tqdm(self.ds.ids[::5]):
            cloud = self.ds.local_cloud(id)
            pose = xyzrpy_matrix(xyzrpy[id][None]).squeeze(0)

            t = timer()
            dc = DepthCloud.from_points(cloud)
            rospy.logdebug('%i points read from dataset %s, (%.3f s).'
                           % (dc.size(), ds.name, timer() - t))  # ~0.06 sec for 180000 pts

            # grid and depth filters
            t = timer()
            dc = filter_depth(dc, min=self.min_depth, max=self.max_depth, log=False)
            rospy.logdebug('%i points kept by depth filter with min_depth %.2f, max_depth %.2f m (%.3f s).'
                           % (dc.size(), self.min_depth, self.max_depth, timer() - t))  # ~0.002 sec

            t = timer()
            dc = filter_grid(dc, self.grid_res, keep='last')
            rospy.logdebug('%i points kept by grid filter with res. %.2f m (%.3f s).'
                           % (dc.size(), self.grid_res, timer() - t))  # ~0.1 sec

            t = timer()
            pose = pose.to(self.device)
            dc = dc.to(self.device)
            rospy.logdebug('moved poses and depth cloud to device (%.3f s).' % (timer() - t))  # ~0.001 sec

            t = timer()
            dc = dc.transform(pose)
            rospy.logdebug('transformed depth cloud to global frame (%.3f s).' % (timer() - t))  # ~0.001 sec

            # eigenvalues filter and depth correction with model
            t = timer()
            dc.update_all(r=self.r_nn)
            rospy.logdebug('update_all took (%.3f s).' % (timer() - t))  # ~2.0 sec on CPU and ~7.5 sec on GPU (!)

            t = timer()
            keep = filter_eigenvalue(dc, 0, max=(self.grid_res / 5) ** 2, only_mask=True, log=False)
            keep = keep & filter_eigenvalue(dc, 1, min=self.grid_res ** 2, only_mask=True, log=False)
            dc = dc[keep]
            dc.update_all(r=self.r_nn)
            rospy.logdebug('filtering eigvals and update_all took (%.3f s).'
                           % (timer() - t))  # ~1.0 sec on CPU and 3.2 sec on GPU (!)

            clouds.append(dc)

        dc_combined = DepthCloud.concatenate(clouds, True)
        return dc_combined

    def run(self):
        rospy.loginfo('Pose optimization started')

        poses = []
        for _, pose in self.ds:
            poses.append(torch.as_tensor(pose[None]))
        n_poses = len(poses)
        poses = torch.concat(poses, dim=0)
        assert poses.shape == (n_poses, 4, 4)

        rpy = matrix_to_euler_angles(poses[:, :3, :3], convention='XYZ')
        assert rpy.shape == (n_poses, 3)
        xyz = poses[:, :3, 3]
        assert xyz.shape == (n_poses, 3)
        xyzrpy = torch.concat([xyz, rpy], dim=1)
        assert xyzrpy.shape == (n_poses, 6)

        xyzrpy.requires_grad = True

        # Initialize optimizer
        optimizer = torch.optim.Adam([xyzrpy], lr=self.lr)
        optimizer.zero_grad()

        for i in range(self.n_iters):
            if rospy.is_shutdown():
                break

            dc_global = self.construct_global_map(self.ds, xyzrpy)

            # pc_msg = dc_to_ros_msg(dc_global_corrected, frame_id=self.world_frame, stamp=rospy.Time.now())
            # self.dc_pubs['corrected'][k].publish(pc_msg)

            dc_global.visualize(colors='inc_angles')

            train_loss, _ = min_eigval_loss(dc_global, r=self.r_nn, offset=True, eigenvalue_bounds=self.eigenvalue_bounds)
            rospy.loginfo('iter N %d, train loss: %g' % (i, train_loss.item()))

            # optimization step
            train_loss.backward()
            optimizer.step()


def main():
    rospy.init_node('pose_optimization', log_level=rospy.INFO)
    pose_opt = PoseOptimizer()
    pose_opt.run()
    rospy.spin()


if __name__ == '__main__':
    main()
