#!/usr/bin/env python

from __future__ import absolute_import, division, print_function

import os
from depth_correction.filters import *
from depth_correction.model import *
from depth_correction.utils import timing
from depth_correction.loss import min_eigval_loss
from data.asl_laser import Dataset, dataset_names
from ros_numpy import msgify, numpify
import rospy
from rospkg import RosPack
from sensor_msgs.msg import PointCloud2
from geometry_msgs.msg import Pose, PoseStamped, Quaternion, Point
from std_msgs.msg import Header
from nav_msgs.msg import Path
import torch
from torch.utils.tensorboard import SummaryWriter
from timeit import default_timer as timer
from pytorch3d.transforms import (axis_angle_to_matrix,
                                  matrix_to_quaternion,
                                  quaternion_to_axis_angle,
                                  axis_angle_to_quaternion)


def cloud_to_ros_msg(dc, frame_id, stamp):
    pc_msg = msgify(PointCloud2, dc.to_structured_array())
    pc_msg.header.frame_id = frame_id
    pc_msg.header.stamp = stamp
    return pc_msg


def xyz_axis_angle_to_matrix(xyz_axis_angle):
    assert isinstance(xyz_axis_angle, torch.Tensor)
    assert xyz_axis_angle.shape[-1] == 6

    mat = torch.zeros(xyz_axis_angle.shape[:-1] + (4, 4), dtype=xyz_axis_angle.dtype, device=xyz_axis_angle.device)
    mat[..., :3, :3] = axis_angle_to_matrix(xyz_axis_angle[..., 3:])
    mat[..., :3, 3] = xyz_axis_angle[..., :3]
    mat[..., 3, 3] = 1.
    assert mat.shape == xyz_axis_angle.shape[:-1] + (4, 4)
    # assert mat.shape[-2:] == (4, 4)
    return mat


def matrix_to_xyz_axis_angle(T):
    assert isinstance(T, torch.Tensor)
    assert T.dim() == 3
    assert T.shape[1:] == (4, 4)
    n_poses = len(T)
    q = matrix_to_quaternion(T[:, :3, :3])
    axis_angle = quaternion_to_axis_angle(q)
    xyz = T[:, :3, 3]
    poses = torch.concat([xyz, axis_angle], dim=1)
    assert poses.shape == (n_poses, 6)
    return poses


def xyz_axis_angle_to_pose_msg(xyz_axis_angle):
    # assert isinstance(xyz_axis_angle, torch.Tensor)
    # assert isinstance(xyz_axis_angle, list)
    q = axis_angle_to_quaternion(xyz_axis_angle[3:])
    msg = Pose(Point(*xyz_axis_angle[:3]), Quaternion(w=q[0], x=q[1], y=q[2], z=q[3]))
    return msg


# @timing
def xyz_axis_angle_to_path_msg(xyz_axis_angle, frame_id, stamp):
    assert isinstance(xyz_axis_angle, torch.Tensor)
    assert xyz_axis_angle.dim() == 2
    assert xyz_axis_angle.shape[-1] == 6
    xyz_axis_angle = xyz_axis_angle.detach()
    msg = Path()
    msg.poses = [PoseStamped(Header(), xyz_axis_angle_to_pose_msg(p)) for p in xyz_axis_angle]
    msg.header.frame_id = frame_id
    msg.header.stamp = stamp
    return msg


class PoseOptimizer(object):
    def __init__(self):
        self.device = torch.device(rospy.get_param('~device', 'cpu'))
        self.lr = rospy.get_param('~lr', 0.001)
        self.dataset_name = rospy.get_param('~dataset_name', dataset_names[0])
        self.ds = Dataset(self.dataset_name)
        self.step = rospy.get_param('~step', 5)
        self.n_iters = rospy.get_param('~n_iters', 100)

        self.r_nn = rospy.get_param('~r_nn', 0.20)
        self.min_depth = rospy.get_param('~min_depth', 1.0)
        self.max_depth = rospy.get_param('~max_depth', 10.0)
        self.grid_res = rospy.get_param('~grid_res', 0.10)
        self.log_filters = rospy.get_param('~log_filters', False)
        self.max_eig_0 = rospy.get_param('~max_eig_0', 0.02**2)
        self.min_eig_1 = rospy.get_param('~max_eig_1', 0.05**2)
        self.dtype = np.float64
        self.train_neighbors = None

        self.world_frame = rospy.get_param('~world_frame', 'world')
        self.poses_pub = rospy.Publisher('poses', Path, queue_size=2)
        self.poses_opt_pub = rospy.Publisher('poses_opt', Path, queue_size=2)
        self.dc_pub = rospy.Publisher('global_cloud', PointCloud2, queue_size=2)
        self.dc_opt_pub = rospy.Publisher('global_cloud_opt', PointCloud2, queue_size=2)

        self.path = RosPack().get_path('depth_correction')
        self.tb_writer = SummaryWriter(os.path.join(self.path,
                                                    'config/tb_runs/poseopt_%s_lr_%g_%f' %
                                                    (self.dataset_name, self.lr, timer())))

    def filtered_cloud(self, cloud):
        cloud = filter_depth(cloud, min=self.min_depth, max=self.max_depth, log=self.log_filters)
        cloud = filter_grid(cloud, grid_res=self.grid_res, keep='random', log=self.log_filters)
        return cloud

    def local_feature_cloud(self, cloud):
        # Convert to depth cloud and transform.
        cloud = DepthCloud.from_structured_array(cloud, dtype=self.dtype)
        cloud = cloud.to(device=self.device)
        # Find/update neighbors and estimate all features.
        cloud.update_all(r=self.r_nn)
        # Select planar regions to correct as in prediction phase.
        mask = filter_eigenvalue(cloud, 0, max=self.max_eig_0, only_mask=True, log=self.log_filters)
        mask = mask & filter_eigenvalue(cloud, 1, min=self.min_eig_1, only_mask=True, log=self.log_filters)
        cloud.mask = mask
        return cloud

    # @timing
    def global_cloud(self, clouds, poses: torch.Tensor) -> DepthCloud:
        assert poses.dim() == 3
        assert poses.shape[1:] == (4, 4)
        transformed_clouds = []
        for i, dc in enumerate(clouds):
            pose = poses[i]
            dc = dc.transform(pose)
            transformed_clouds.append(dc)
        cloud = DepthCloud.concatenate(transformed_clouds, True)
        return cloud

    def run(self):
        rospy.loginfo('pose optimization started')

        clouds = []
        Ts = []
        for cloud, T in Dataset(self.dataset_name)[::self.step]:
            cloud = self.filtered_cloud(cloud)
            cloud = self.local_feature_cloud(cloud)
            # If poses are not optimized, depth can be corrected on global
            # feature clouds.
            # If poses are to be optimized, depth can be corrected on local
            # clouds and these can then be transformed to global cloud.
            clouds.append(cloud)
            Ts.append(torch.as_tensor(T)[None])
        n_poses = len(Ts)
        Ts = torch.concat(Ts, dim=0)
        assert Ts.shape == (n_poses, 4, 4)

        pose_deltas = torch.zeros((1, 6), dtype=Ts.dtype)  # same correction broadcasted to all poses x, y, z, *a
        pose_deltas.requires_grad = True

        # Initialize optimizer
        optimizer = torch.optim.Adam([pose_deltas], lr=self.lr)

        pc_msg = None
        path_msg = None
        mask = None
        for i in range(self.n_iters):
            optimizer.zero_grad()

            if rospy.is_shutdown():
                break

            pose_deltas_mat = xyz_axis_angle_to_matrix(pose_deltas)
            poses = torch.matmul(Ts, pose_deltas_mat)
            dc_opt_global = self.global_cloud(clouds, poses)
            if self.train_neighbors is None:
                dc_opt_global.update_all(r=self.r_nn)
                self.train_neighbors = dc_opt_global.neighbors, dc_opt_global.weights
                mask = filter_eigenvalue(dc_opt_global, 0, max=self.max_eig_0, only_mask=True, log=self.log_filters)
                mask = mask & filter_eigenvalue(dc_opt_global, 1, min=self.min_eig_1, only_mask=True, log=self.log_filters)
                rospy.loginfo('Optimizing on %.3f = %i / %i points.'
                              % (mask.float().mean().item(), mask.sum().item(), mask.numel()))
            else:
                dc_opt_global.neighbors, dc_opt_global.weights = self.train_neighbors
                dc_opt_global.update_all(r=self.r_nn, keep_neighbors=True)

            train_loss, _ = min_eigval_loss(dc_opt_global, mask=mask)
            rospy.loginfo('iter N %d, train loss: %g' % (i, train_loss.item()))

            # publish poses and clouds
            stamp = rospy.Time.now()
            pc_opt_msg = cloud_to_ros_msg(dc_opt_global, frame_id=self.world_frame, stamp=stamp)
            path_opt_msg = xyz_axis_angle_to_path_msg(matrix_to_xyz_axis_angle(poses),
                                                      frame_id=self.world_frame, stamp=stamp)
            if i == 0:
                pc_msg = pc_opt_msg
                path_msg = path_opt_msg
            self.dc_pub.publish(pc_msg)
            self.dc_opt_pub.publish(pc_opt_msg)

            self.poses_pub.publish(path_msg)
            self.poses_opt_pub.publish(path_opt_msg)

            # Tensorboard logging
            self.tb_writer.add_scalar("min_eigval_loss/train", train_loss, i)
            self.tb_writer.add_scalar("pose_correction/dx", pose_deltas.squeeze(0)[0], i)
            self.tb_writer.add_scalar("pose_correction/dy", pose_deltas.squeeze(0)[1], i)
            self.tb_writer.add_scalar("pose_correction/dz", pose_deltas.squeeze(0)[2], i)
            # self.tb_writer.add_scalar("pose_correction/da", torch.linalg.norm(poses_corr.squeeze(0)[3:]), i)
            self.tb_writer.add_scalar("pose_correction/dax", pose_deltas.squeeze(0)[3], i)
            self.tb_writer.add_scalar("pose_correction/day", pose_deltas.squeeze(0)[4], i)
            self.tb_writer.add_scalar("pose_correction/daz", pose_deltas.squeeze(0)[5], i)

            # optimization step
            train_loss.backward()
            optimizer.step()


def main():
    rospy.init_node('pose_optimization', log_level=rospy.INFO)
    pose_opt = PoseOptimizer()
    pose_opt.run()
    rospy.spin()


if __name__ == '__main__':
    main()
