#!/usr/bin/env python

from __future__ import absolute_import, division, print_function
from depth_correction.depth_cloud import DepthCloud
from depth_correction.filters import filter_depth, filter_eigenvalue, filter_grid
from depth_correction.loss import min_eigval_loss
from depth_correction.model import *
from depth_correction.utils import timer, timing
import importlib
import numpy as np
import torch
from torch.utils.tensorboard import SummaryWriter
from pytorch3d.transforms import (axis_angle_to_matrix,
                                  matrix_to_quaternion,
                                  quaternion_to_axis_angle,
                                  axis_angle_to_quaternion)
from tqdm import tqdm
import os
import rospy
from sensor_msgs.msg import PointCloud2
from std_msgs.msg import Header
from nav_msgs.msg import Path
from geometry_msgs.msg import Point, Pose, PoseStamped, Quaternion
from ros_numpy import msgify
from rospkg import RosPack


# pkg_dir = os.path.abspath(os.path.join(os.getcwd(), os.pardir))
pkg_dir = RosPack().get_path('depth_correction')
# pkg_dir = "/home/ruslan/DepthCorrection/depth_correction"
print(pkg_dir)

# MODEL_TYPE = 'Linear'
MODEL_TYPE = 'Polynomial'
# MODEL_TYPE = 'ScaledPolynomial'
# MODEL_TYPE = 'InvCos'
# MODEL_TYPE = 'ScaledInvCos'

N_OPT_ITERS = 100
LR = 1e-2
# LR = 1e-3
# LR = 1e-4
# LR = 1e-6
SHOW_RESULTS = False

DATASET = 'semantic_kitti'
print(DATASET)

dtype = np.float64
# dtype = torch.float64
device = torch.device('cpu')
# device = torch.device('cuda')

min_depth = 1.0
max_depth = 15.0
grid_res = 0.20

k = None
r = 0.30
max_eig_0 = 0.02 ** 2
min_eig_1 = 0.05 ** 2
n_train_subseqs = 15
n_val_subseqs = 5
data_sequence_step = 20
local_cloud_step = 3
log_filters = False

rospy.init_node('depth_correction', log_level=rospy.INFO)

# from eval('data.%s' % dataset) import Dataset, dataset_names
# eval('from data.%s import Dataset, dataset_names' % dataset)
imported_module = importlib.import_module("data.%s" % DATASET)
Dataset = getattr(imported_module, "Dataset")
dataset_names = getattr(imported_module, "dataset_names")
rospy.loginfo('Using %s datasets %s.' % (DATASET, ', '.join(dataset_names)))

train_sequence = '01'
val_sequence = '03'
rospy.loginfo('Training set: %s.' % train_sequence)
rospy.loginfo('Validation set: %s.' % val_sequence)


# @timing
def filtered_cloud(cloud):
    cloud = filter_depth(cloud, min=min_depth, max=max_depth, log=log_filters)
    cloud = filter_grid(cloud, grid_res=grid_res, keep='random', log=log_filters)
    return cloud


# @timing
def filtered_clouds(ds: Dataset):
    clouds = []
    poses = []
    for i, (cloud, pose) in enumerate(ds):
        cloud = filtered_cloud(cloud)
        clouds.append(cloud)
        poses.append(pose)
    return list(zip(clouds, poses))


# @timing
def local_feature_cloud(cloud):
    # Convert to depth cloud and transform.
    if cloud.dtype.names:
        cloud = DepthCloud.from_structured_array(cloud, dtype=dtype)
    else:
        cloud = DepthCloud.from_points(cloud, dtype=dtype)
    cloud = cloud.to(device=device)
    # Find/update neighbors and estimate all features.
    cloud.update_all(k=k, r=r)
    # Select planar regions to correct as in prediction phase.
    mask = filter_eigenvalue(cloud, 0, max=max_eig_0, only_mask=True, log=log_filters)
    mask = mask & filter_eigenvalue(cloud, 1, min=min_eig_1, only_mask=True, log=log_filters)
    cloud.mask = mask
    return cloud


# @timing
def local_feature_clouds(ds):
    clouds = []
    poses = []
    for i, (cloud, pose) in enumerate(ds):
        cloud = local_feature_cloud(cloud)
        pose = torch.as_tensor(pose, device=device)
        clouds.append(cloud)
        poses.append(pose)
    return list(zip(clouds, poses))


def global_cloud(clouds: (list, tuple),
                 model: BaseModel,
                 poses: torch.Tensor):
    """Create global cloud with corrected depth.

    :param clouds: Filtered local features clouds.
    :param model: Depth correction model, directly applicable to clouds.
    :param poses: N-by-4-by-4 pose tensor to transform clouds to global frame.
    :return: Global cloud with corrected depth.
    """
    transformed_clouds = []
    for i, cloud in enumerate(clouds):
        cloud = model(cloud)
        cloud = cloud.transform(poses[i])
        transformed_clouds.append(cloud)
    cloud = DepthCloud.concatenate(transformed_clouds, True)
    # cloud.visualize(colors='z')
    # cloud.visualize(colors='inc_angles')
    return cloud


def global_clouds(clouds, model, poses):
    ret = []
    for c, p in zip(clouds, poses):
        cloud = global_cloud(c, model, p)
        ret.append(cloud)
    return ret


def cloud_to_ros_msg(dc, frame_id, stamp):
    pc_msg = msgify(PointCloud2, dc.to_structured_array())
    pc_msg.header.frame_id = frame_id
    pc_msg.header.stamp = stamp
    return pc_msg


def xyz_axis_angle_to_pose_msg(xyz_axis_angle):
    # assert isinstance(xyz_axis_angle, torch.Tensor)
    # assert isinstance(xyz_axis_angle, list)
    q = axis_angle_to_quaternion(xyz_axis_angle[3:])
    msg = Pose(Point(*xyz_axis_angle[:3]), Quaternion(w=q[0], x=q[1], y=q[2], z=q[3]))
    return msg


# @timing
def xyz_axis_angle_to_path_msg(xyz_axis_angle, frame_id, stamp):
    assert isinstance(xyz_axis_angle, torch.Tensor)
    assert xyz_axis_angle.dim() == 2
    assert xyz_axis_angle.shape[-1] == 6
    xyz_axis_angle = xyz_axis_angle.detach()
    msg = Path()
    msg.poses = [PoseStamped(Header(), xyz_axis_angle_to_pose_msg(p)) for p in xyz_axis_angle]
    msg.header.frame_id = frame_id
    msg.header.stamp = stamp
    return msg


def xyz_axis_angle_to_matrix(xyz_axis_angle):
    assert isinstance(xyz_axis_angle, torch.Tensor)
    assert xyz_axis_angle.shape[-1] == 6

    mat = torch.zeros(xyz_axis_angle.shape[:-1] + (4, 4), dtype=xyz_axis_angle.dtype, device=xyz_axis_angle.device)
    mat[..., :3, :3] = axis_angle_to_matrix(xyz_axis_angle[..., 3:])
    mat[..., :3, 3] = xyz_axis_angle[..., :3]
    mat[..., 3, 3] = 1.
    assert mat.shape == xyz_axis_angle.shape[:-1] + (4, 4)
    # assert mat.shape[-2:] == (4, 4)
    return mat


def matrix_to_xyz_axis_angle(T):
    assert isinstance(T, torch.Tensor)
    assert T.dim() == 3
    assert T.shape[1:] == (4, 4)
    n_poses = len(T)
    q = matrix_to_quaternion(T[:, :3, :3])
    axis_angle = quaternion_to_axis_angle(q)
    xyz = T[:, :3, 3]
    poses = torch.concat([xyz, axis_angle], dim=1)
    assert poses.shape == (n_poses, 6)
    return poses


@timing
def publish_data(clouds: list, poses: list, cloud_topic='global_cloud', poses_topic='poses', frame_id='world'):
    for cloud in clouds:
        assert isinstance(cloud, DepthCloud)
    for pose in poses:
        isinstance(pose, torch.Tensor)
        assert pose.dim() == 3
        assert pose.shape[1:] == (4, 4)

    cloud = DepthCloud.concatenate(clouds, dependent=False)
    poses = torch.concat(poses, dim=0)

    poses_pub = rospy.Publisher(poses_topic, Path, queue_size=2)
    dc_pub = rospy.Publisher(cloud_topic, PointCloud2, queue_size=2)
    stamp = rospy.Time.now()

    pc_opt_msg = cloud_to_ros_msg(cloud, frame_id=frame_id, stamp=stamp)
    path_opt_msg = xyz_axis_angle_to_path_msg(matrix_to_xyz_axis_angle(poses),
                                              frame_id=frame_id, stamp=stamp)
    dc_pub.publish(pc_opt_msg)
    poses_pub.publish(path_opt_msg)


def main():
    # Cloud needs to retain neighbors, weights, and mask from previous
    # iterations.
    # Depth correction is applied based on local cloud statistics.
    # Loss is computed based on global cloud statistics.

    train_clouds = []
    train_poses = []
    # Pose corrections 3 translation, 3 elements axis-angle,.
    train_pose_deltas = []
    train_neighbors = [None] * n_train_subseqs
    train_masks = [None] * n_train_subseqs
    ds_train = Dataset(train_sequence)
    for i in range(n_train_subseqs):
        clouds_val = []
        poses = []
        for cloud, pose in ds_train[i * data_sequence_step:(i + 1) * data_sequence_step:local_cloud_step]:
            # print('%i points read' % cloud.shape[0])
            cloud = filtered_cloud(cloud)
            cloud = local_feature_cloud(cloud)
            # If poses are not optimized, depth can be corrected on global
            # feature clouds.
            # If poses are to be optimized, depth can be corrected on local
            # clouds and these can then be transformed to global cloud.
            clouds_val.append(cloud)
            poses.append(pose)
        train_clouds.append(clouds_val)
        poses = np.stack(poses).astype(dtype=dtype)
        poses = torch.as_tensor(poses, device=device)
        train_poses.append(poses)
        pose_deltas = torch.zeros((poses.shape[0], 6), dtype=poses.dtype)
        pose_deltas.requires_grad = True
        train_pose_deltas.append(pose_deltas)

    val_clouds = []
    val_poses = []
    val_pose_deltas = []
    val_neighbors = [None] * n_val_subseqs
    val_masks = [None] * n_val_subseqs
    ds_val = Dataset(val_sequence)
    for i in range(n_val_subseqs):
        clouds_val = []
        poses = []
        for cloud, pose in ds_val[i * data_sequence_step:(i + 1) * data_sequence_step:local_cloud_step]:
            cloud = filtered_cloud(cloud)
            cloud = local_feature_cloud(cloud)
            clouds_val.append(cloud)
            poses.append(pose)
        val_clouds.append(clouds_val)
        poses = np.stack(poses).astype(dtype=dtype)
        poses = torch.as_tensor(poses, device=device)
        val_poses.append(poses)
        pose_deltas = torch.zeros((poses.shape[0], 6), dtype=poses.dtype)
        val_pose_deltas.append(pose_deltas)

    # Create model
    model = eval(MODEL_TYPE)(device=device)
    print(model)

    # Initialize optimizer
    # optimizer = torch.optim.Adam(model.parameters(), lr=LR)
    # optimizer = torch.optim.SGD(model.parameters(), lr=LR, momentum=0.9, nesterov=True)
    # optimizer = torch.optim.SGD(train_pose_deltas, lr=LR, momentum=0.9, nesterov=True)
    optimizer = torch.optim.SGD([{'params': model.parameters(), 'lr': LR},
                                 {'params': train_pose_deltas, 'lr': LR}], momentum=0.9, nesterov=True)

    writer = SummaryWriter(os.path.join(pkg_dir, '%s/config/tb_runs/model_%s_lr_%f_%s_%f'
                           % (pkg_dir, MODEL_TYPE, LR, DATASET, timer())))

    min_loss = np.inf
    for it in range(N_OPT_ITERS):
        if rospy.is_shutdown():
            break

        optimizer.zero_grad()

        # Training
        # Allow optimizing pose deltas.
        if train_pose_deltas is None:
            train_poses_upd = train_poses
        else:
            # Convert pose deltas to matrices
            train_poses_upd = []
            for i in range(len(train_poses)):
                pose_deltas_mat = xyz_axis_angle_to_matrix(train_pose_deltas[i])
                train_poses_upd.append(torch.matmul(train_poses[i], pose_deltas_mat))

        clouds_train = global_clouds(train_clouds, model, train_poses_upd)
        # if it == 0:
        #     for cloud in clouds:
        #         cloud.visualize(window_name='Train cloud')

        for i in range(len(clouds_train)):
            cloud = clouds_train[i]
            if train_neighbors[i] is None:
                cloud.update_all(k=k, r=r)
                train_neighbors[i] = cloud.neighbors, cloud.weights
                mask = filter_eigenvalue(cloud, 0, max=max_eig_0, only_mask=True, log=log_filters)
                mask = mask & filter_eigenvalue(cloud, 1, min=min_eig_1, only_mask=True, log=log_filters)
                rospy.loginfo('Training on %.3f = %i / %i points.'
                              % (mask.float().mean().item(), mask.sum().item(), mask.numel()))
                train_masks[i] = mask
            else:
                cloud.neighbors, cloud.weights = train_neighbors[i]
                cloud.update_all(k=k, r=r, keep_neighbors=True)
            clouds_train[i] = cloud

        train_loss, _ = min_eigval_loss(clouds_train, mask=train_masks)

        # Validation
        if train_pose_deltas is None:
            val_poses_upd = val_poses
        else:
            assert len(val_poses) == len(val_pose_deltas)
            # Use the deltas from validation.
            val_poses_upd = []
            for i in range(len(val_poses)):
                pose_deltas_mat = xyz_axis_angle_to_matrix(val_pose_deltas[i])
                val_poses_upd.append(torch.matmul(val_poses[i], pose_deltas_mat))

        clouds_val = global_clouds(val_clouds, model, val_poses_upd)
        # if it == 0:
        #     for cloud in clouds:
        #         cloud.visualize(window_name='Val cloud')

        for i in range(len(clouds_val)):
            cloud = clouds_val[i]
            if val_neighbors[i] is None:
                cloud.update_all(k=k, r=r)
                val_neighbors[i] = cloud.neighbors, cloud.weights
                mask = filter_eigenvalue(cloud, 0, max=max_eig_0, only_mask=True, log=log_filters)
                mask = mask & filter_eigenvalue(cloud, 1, min=min_eig_1, only_mask=True, log=log_filters)
                rospy.loginfo('Validating on %.3f = %i / %i points.'
                              % (mask.float().mean().item(), mask.sum().item(), mask.numel()))
                val_masks[i] = mask
            else:
                cloud.neighbors, cloud.weights = val_neighbors[i]
                cloud.update_all(k=k, r=r, keep_neighbors=True)
            clouds_val[i] = cloud

        val_loss, _ = min_eigval_loss(clouds_val, mask=val_masks)

        if val_loss.item() < min_loss:
            saved = True
            min_loss = val_loss.item()
            torch.save(model.state_dict(),
                       os.path.join(pkg_dir,
                                    '%s/config/weights/%s_train_%s_val_%s_r%.2f_eig_%.4f_%.4f_min_eigval_loss_%.9f.pth'
                                    % (pkg_dir, MODEL_TYPE, ','.join(train_sequence), ','.join(val_sequence),
                                       r, max_eig_0, min_eig_1, val_loss.item())))
        else:
            saved = False

        rospy.loginfo('It. %i: training loss: %.9f, validation: %.9f. Model %s %s.'
                      % (it, train_loss.item(), val_loss.item(), model, 'saved' if saved else 'not saved'))

        # publish (validation) poses and clouds
        if rospy.get_param('~publish_data', False):
            if it == 0:
                publish_data(clouds_train, train_poses_upd,
                             cloud_topic='global_cloud_train', poses_topic='poses_train', frame_id='world')
                publish_data(clouds_val, val_poses_upd,
                             cloud_topic='global_cloud_val', poses_topic='poses_val', frame_id='world')

        writer.add_scalar("min_eigval_loss/train", train_loss, it)
        writer.add_scalar("min_eigval_loss/val", val_loss, it)
        for i in range(len(val_sequence)):
            writer.add_histogram("pose_correction/train/%s/dx" % train_sequence, train_pose_deltas[i][:, 0], it)
            writer.add_histogram("pose_correction/train/%s/dy" % train_sequence, train_pose_deltas[i][:, 1], it)
            writer.add_histogram("pose_correction/train/%s/dz" % train_sequence, train_pose_deltas[i][:, 2], it)
            writer.add_histogram("pose_correction/train/%s/dax" % train_sequence, train_pose_deltas[i][:, 3], it)
            writer.add_histogram("pose_correction/train/%s/day" % train_sequence, train_pose_deltas[i][:, 4], it)
            writer.add_histogram("pose_correction/train/%s/daz" % train_sequence, train_pose_deltas[i][:, 5], it)

        # Optimization step
        optimizer.zero_grad()
        train_loss.backward()
        optimizer.step()

    writer.flush()
    writer.close()


if __name__ == '__main__':
    main()
